{"meta":{"title":"howard Yao","subtitle":"居安思危","description":"居安思危","author":"howard Yao","url":"http://yoursite.com"},"pages":[{"title":"All tags","date":"2014-12-22T04:39:04.000Z","updated":"2019-05-04T07:47:02.977Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"howard Yao","date":"2018-10-26T08:24:07.000Z","updated":"2019-05-04T07:47:02.951Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"All categories","date":"2018-10-28T07:55:53.000Z","updated":"2019-05-04T07:47:02.952Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"redis的数据类型","slug":"redis的数据类型","date":"2019-10-19T08:50:57.000Z","updated":"2019-10-19T11:25:38.758Z","comments":true,"path":"2019/10/19/redis的数据类型/","link":"","permalink":"http://yoursite.com/2019/10/19/redis的数据类型/","excerpt":"","text":"redis的数据类型redis支持5种数据类型(对象)。分别是字符串(String)、列表(list)、哈希(hash)、集合(set)、有序集合(zset/sorted set)。redis中的键和值都是一个对象。redis使用引用计数实现内存回收，当一个对象不再被使用时，会被回收。每个对象也会记录最后一次被访问的时间，可用于计数空转时间(回收算法为lru时有用) 字符串String 字符串对象的编码可以是int、raw、embstr。当保存的是整型，则是int，不大于某个阈值(不同版本阈值可能不一样)的字符串，则为embstr，其余大字符串则是raw，raw本质上是SDS(简单动态字符串)。 字符串对象是二进制安全的，因为其使用的是len来记录长度，和c语言不同，所以可以存放图片等二进制数据。 redis会共享值为0-9999的字符串对象。 可通过OBJECT ENCODING key来查看编码。其它类型也一样。 常见命令：1234567891011121314151617181920212223242526# 设置指定 key 的值SET key value# 获取指定 key 的值GET key # 返回 key 中字符串值的子字符GETRANGE key start end# 将给定 key 的值设为 value ，并返回 key 的旧值GETSET key value# 设置指定key的值和过期时间。单位秒SETEX key seconds value# 只有在 key 不存在时设置 key 的值SETNX key value# 返回key所储存的字符串值的长度STRLEN key# key值+1INCR key# key值增加incrementINCRBY key increment# key值增加increment 浮点类型INCRBYFLOAT key increment# key值-1DECR key# key值减少incrementDECRBY key decrement# 指定key追加valueAPPEND key value 列表list 列表对象的编码可以是ziplist或linkedList。 ziplist使用压缩列表实现，linkedList使用双端链表实现。 长度和元素个数满足条件(不超过，不同redis版本不一样)才会使用ziplist，超过则使用linkedlist linkedlist编码的列表对象底层还有使用string对象。字符串对象是redis的5种对象中唯一一种会被其它四种对象嵌套的对象。 常见命令123456789101112# 将一个或多个值插入到列表头部LPUSH key value1 [value2]# 在列表尾部中添加一个或多个值RPUSH key value1 [value2]# 列表长度LLEN key# 移出并获取列表的第一个元素LPOP key# 移除列表元素LREM key count value# 移除列表的最后一个元素，返回值为移除的元素RPOP key 哈希Hash 哈希对象的编码可以是ziplist或hashtable ziplist使用压缩列表实现(键值依次压入列表尾)，hashtable使用字符串实现，键和值都是一个字符串对象 长度和元素个数满足条件(不超过，不同redis版本不一样)才会使用ziplist，超过则转换为hashtable 常见命令：123456789101112# 删除哈希表中指定字段的值HDEL key field1 [field2]# 获取哈希表中指定字段的值HGET key field# 查看哈希表 key 中，指定的字段是否存在HEXISTS key field# 获取哈希表key的所有字段和值HGETALL key# 获取所有哈希表中的字段HKEYS key# 获取哈希表中字段的数量HLEN key+ 集合set 集合对象的编码可以是intset或hashtable intset使用整数集合实现，有序。hashtable使用字典实现，字典的值都设为null 长度和元素个数满足条件(不超过，不同redis版本不一样)，并且保存的值不包含字符串时才会使用intset，否则转换为hashtable。 常见命令：12345678# 向集合key添加一个或多个成员SADD key member1 [member2]# 获取集合的成员数SCARD key# 返回给定所有集合的差集SDIFF key1 [key2]# 判断 member 元素是否是集合 key 的成员SISMEMBER key member 有序集合sorted set 有序,不允许重复 有序集合对象的编码可以是ziplist或skiplist ziplist使用压缩列表作为底层实现，每个集合元素使用2个紧挨的压缩节点保存，一个保存元素，一个保存元素的分值(score)。压缩列表内的元素按分值从小到大排序。 skiplist编码使用zset结构作为底层实现，zset结构包含一个字典和一个跳跃表。字典dict保存了元素的成员到分值的映射，键是成员，字典的值则是元素对应的分值，利用字典可以用O(1)的时间复杂度找到给定成员的分值。跳表则按分值从小到大保存了集合的成员，通过跳表可以进行范围查找。 为什么同时使用跳表和字典？因为跳表不适合根据成员找到分值，时间复杂度O(logN)，而字典是无序的，每次范围查找都要额外排序O(NlogN)时间复杂度和O(N)空间复杂度。 字典和跳表通过指针来共享元素的成员和分值。不会存储重复的成员和分值。 长度和元素个数满足条件(不超过，不同redis版本不一样)才会使用ziplist，超过则使用skiplist。 常见命令：123456789101112# 向有序集合添加一个或多个成员，或者更新已存在成员的分数ZADD key score1 member1 [score2 member2]# 获取有序集合的成员数ZCARD key# 计算在有序集合中指定区间分数的成员数ZCOUNT key min max# 有序集合中对指定成员的分数加上增量 incrementZINCRBY key increment member# 返回有序集合中指定成员的索引ZRANK key member# 返回有序集中，成员的分数值ZSCORE key member 小结对于上面5中对象可能用到的编码总结如下： 对象类型 编码 字符串 int、raw、embstr 列表 ziplist、linkedlist 哈希 ziplist、hashtable 集合 intset、hashtable 有序集合 ziplist、skiplist 对于各自编码所对应的数据结构，会在后面有空的时候另行总结。 本文总结自《redis设计与实现》","categories":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/categories/redis/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/categories/redis/"}]},{"title":"浅谈LinkedHashMap","slug":"浅谈LinkedHashMap","date":"2019-05-19T07:19:28.000Z","updated":"2019-05-19T07:37:14.100Z","comments":true,"path":"2019/05/19/浅谈LinkedHashMap/","link":"","permalink":"http://yoursite.com/2019/05/19/浅谈LinkedHashMap/","excerpt":"","text":"引入LinkedHashMap也是java中常用的集合类之一，LinkedHashMap在jdk1.7与jdk1.8也有一点区别，其中一部分区别来源于其父类HashMap在jdk1.8的变化。本篇主要简单记录下jdk1.7(1.7.0_06 具体版本不同也有一定的差别)下LinkedHashMap的主要实现原理，对于jdk1.8的LinkedHashMap其基本原理差不多，故没有花大量的时间去了解，仅仅简单看了下一些变化。会在后面简单说下区别。 关系LinkedHashMap的继承关系如下：123public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123; //省略一堆代码。。。&#125; 主要继承了HashMap和实现了Map，所以实现上与hashMap有很多是一样的，了解LinkHashMap之前需要先去了解HashMap的主要实现。这里主要谈谈LinkedHashMap，所以对于HashMap的不会花太多去描述。可参考网上资料和之前的文章。HashMap继承自AbstractMap，同时实现了Map、Cloneable和Serializable接口。HashMap的关系如下:12345public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable&#123; //省略一堆代码。。。 &#125; 使用与HashMap不同的是，LinkedHashMap是有序的123456789101112public static void main(String[] args) &#123; Map&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;(); linkedHashMap.put(\"test01\",\"a1\"); linkedHashMap.put(\"test02\",\"a2\"); linkedHashMap.put(\"test03\",\"a3\"); Set&lt;Map.Entry&lt;String, String&gt;&gt; mapSet = linkedHashMap.entrySet(); for (Map.Entry&lt;String, String&gt; entry : mapSet) &#123; String key = entry.getKey(); String value = entry.getValue(); System.out.println(key + \" \" + value); &#125;&#125; 该程序运行后的结果与put的顺序是一致的。 test01 a1test02 a2test03 a3 除此外，LinkedHashMap还常被用于LRU缓存。那么LinkedHashMap是怎么保证其有序和实现LRU的呢？ 存储结构LinkedHashMap在HashMap成员变量的基础上，又新增了两个变量：123456789101112/** * The head of the doubly linked list. */private transient Entry&lt;K,V&gt; header;/** * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt; * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order. * * @serial */private final boolean accessOrder; 其中，accessOrder默认为false，这点在构造函数中可以看到。该参数主要是用于设置是否在访问键值对的时候对key进行排序，false表示不会进行排序，后面会介绍该参数具体的体现。Entry是LinkedHashMap的静态内部类，该类也继承于HashMap的内部类Entry。其主要实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * LinkedHashMap entry. */private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123; // These fields comprise the doubly linked list used for iteration. Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; /** * Removes this entry from the linked list. */ private void remove() &#123; before.after = after; after.before = before; &#125; /** * Inserts this entry before the specified existing entry in the list. */ private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; &#125; /** * This method is invoked by the superclass whenever the value * of a pre-existing entry is read by Map.get or modified by Map.set. * If the enclosing Map is access-ordered, it moves the entry * to the end of the list; otherwise, it does nothing. */ void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; if (lm.accessOrder) &#123; lm.modCount++; remove(); addBefore(lm.header); &#125; &#125; void recordRemoval(HashMap&lt;K,V&gt; m) &#123; remove(); &#125;&#125; 可以看到该类的变量是其自身，before和after，看到这里估计猜出来了，LinkedHashMap内部类Entry实际上维护的是一个双向链表，before和after分别指向前一个结点和后一个结点，而且还是一个循环双向链表，这点在插入的代码可以看出(jdk1.8改变了这点，并不是循环的双向链表)。而LinkedHashMap又是继承于HashMap的，所以底层大部分实现是跟HashMap类似的，而HashMap是数组+链表(用于拉链法)，jdk1.8之后的HashMap对于链表大于8个元素的还会转化为红黑树。所以可以猜测LinkedHashMap是HashMap+双向链表的实现方式，而这里的双向链表就是为了维护元素的顺序。LinkHashMap的成员变量header实际上是该双向链表的头结点。这里简单附上一个图供参考： 构造方法LinkedHashMap提供了5个构造方法： LinkedHashMap()1234public LinkedHashMap() &#123; super(); accessOrder = false;&#125; 这里可以看到accessOrder默认设置为false。super调用的是hashmap的构造方法。在该方法里，设置了默认容量16和默认的负载因子0.75，具体代码就不贴出来了，可以自行查看。HashMap的构造方法最终调用的是HashMap(int initialCapacity, float loadFactor)：在HashMap中init()方法是空实现，而在linkedHashMap中则实现了该方法，所以在构造函数调用过程最终也有调用linkedHashMap的init方法，该方法具体实现如下:在该方法中，会初始化双向链表的头结点，即new一个内部的entry对象，并将其首尾连接形成双向链表： LinkedHashMap(int initialCapacity)1234public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false;&#125; accessOrder默认设置为false。自定义了初始化容量，super调用的是hashmap的构造方法。在该方法里，设置了容量initialCapacity(实际上会找到大于等于initialCapacity且是2的n次幂的最小数,容量7-&gt;8,14-&gt;16, 看了几个版本的jdk这里的初始化的时间略有不同)和默认的负载因子0.75,可看上面的截图。同样的，也会调用init方法。 LinkedHashMap(int initialCapacity, float loadFactor)1234public LinkedHashMap(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); accessOrder = false;&#125; 与LinkedHashMap(int initialCapacity)类似，但指定了负载因子。 HashMap(Map&lt;? extends K, ? extends V&gt; m)1234public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; super(m); accessOrder = false;&#125; 初始化的同时传入Map参数，设置相应的键值对，LinkHashMap的容量由传入的集合和默认的初始化大小来比较共同决定。主要实现参考HashMap相应构造方法。 LinkedHashMap(int initialCapacity, float loadFactor,boolean accessOrder)123456public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 和前面类似，指定了accessOrder。 PutLinkedHashMap并没有看到put方法，所以其调用的还是HashMap的方法。这里主要注意的是LinkedHashMap重写了的几个方法：void recordAccess(HashMap&lt;K,V&gt; m)void addEntry(int hash, K key, V value, int bucketIndex)void createEntry(hash, key, value, bucketIndex);void transfer(HashMap.Entry[] newTable, boolean rehash) addEntry()注意LinkedHashMap重写了addEntry方法。在该方法中，先调用了HashMap中addEntry方法：该方法主要做了扩容判断和扩容操作(这里linedhashmap扩容操作后的rehash方法也有所变化)，最后会调用createEntry方法创建元素。 createEntry()LinkHashMap也对createEntry进行了重写：在该方法中，会创建新的Entry并存放与相应的槽(数组对应位置)的表头，然后再将其加入双向链表。这里仅看调用addBefore方法前后双向链表的变化如图：这里的after和before是相对header而言的，加入a3后后如图： 再回过头来看addEntry方法，在LinkedHashMap的addEntry方法中，除了调用HashMap的addEntry方法，在下面还有一步if判断removeEldestEntry(eldest)，eldest指向头结点的下一个结点，也就是在我们看来的双向链表的第一个结点，而这里LinkedHashMap并没有具体实现removeEldestEntry，而仅是返回了false，所以默认情况下，这步if是不会返回true。关于这里这么做的用处，留到后面再说。 transfer 双向链表遍历再往回看，在调用HashMap的addEntry方法中，会先对hashmap的容量(这里实际指linkedHashMap的容量)做判断，超过threshold则会进行resize即扩容，扩容原理与HashMap的一致的，但在扩容后的rehash过程会调用transfer方法，LinkedHashMap对该方法也重写了：在HashMap中该方法是遍历table数组，对每个槽的链表进行遍历来完成rehash（重新计算Hash值存放到新数组的对应的位置里），而LinkedHashMap则换了另一种遍历方式，遍历其双向链表来达到reHash的目的。后者显然编码会简单容易看懂些，且效率整体上会略好与前者（因为你不能确定table数组每个位置都一定有键值对存放）。 recordAccess 重排序前面提到，LinkedHashMap有个accessOrder参数，该参数用来设置是否重排序，true表示会进行重排序，即在put和get的过程中，会将访问到的元素从链表中移除，添加到链尾部。这里仅看看put过程的重排实现，get中也有类似的实现，留待后面分析get方法的时候再看。HashMap对recordAccess方法是空实现的，而LinkedhashMap重写了该方法，如图：当accessOrder为true时，且在put过程中已存在该key时，LinkedHashMap除了会覆盖该key的值外，会认为该key被访问了，所以还会对该key进行重排序。在方法中，remove会从链表中移除该结点，然后调用addBefore将该结点加入到链表尾部。get方法也会进行类似的判断和操作。其中，modCount涉及到集合的快速失败机制（fast-fail），是另一个知识点了，这里不展开说了。可去参考前面的文章。 GetLinkedHashMap重写了get方法：在该方法中，调用了HashMap的getEntry方法来获取key的value，该方法主要是遍历table和链表来获取指定key的value，具体实现参考hashmap的getEntry,这里不展开重复叙述。除此外，还调用了前面提到的recordAccess方法，判断是否需要重排序，如果为true则会将被访问到的entry从链表移除并添加到双向链表尾部。 containsValueLinkedHashMap重写了containsValue方法，该方法很简单，就是遍历双向链表判断是否存在值为value的键值对。在HashMap中该方法的实现是遍历数组+链表，而由于LinkedHashMap维护了双向链表，所以利用该优势直接遍历一次该链表即可。 clearLinkedHashMap重写了clear方法。在重写的方法中，先是调用了父类HashMap的clear方法，然后在将双向链表的头部header的首尾相连，使之自己形成环(就如刚刚初始化那样)，从而与其他数据脱离关系。而在父类的clear方法中将table数组的每个都设置为null，并将存储数据量size设置为0。 remove由于LinkedHashMap相比HashMap，多维护了双向链表这一结构，所以在移除数据的时候，除了需要像HashMap那样从table+链表这个结构里移除外，还需要从双向链表中移除的，而LinkedHashMap并没有重写remove方法，在HashMap的remove方法中： 可以看到调用了recordRemoval()，在HashMap中该方法是个空实现，而LinkedHashMap则重写了该方法：通过调用remove将当前entry从链表中移除。 遍历Map的遍历有好几种方式，这里就仅拿entrySet的方式说明。123456789101112Map&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();linkedHashMap.put(\"a\",\"1\");linkedHashMap.put(\"b\",\"1\");linkedHashMap.put(\"c\",\"1\");Set&lt;Map.Entry&lt;String, String&gt;&gt; set = linkedHashMap.entrySet();Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = set.iterator();while(iterator.hasNext()) &#123; Map.Entry entry = iterator.next(); String key = (String) entry.getKey(); String value = (String) entry.getValue(); System.out.println(key + \" \" + value);&#125; 一步一步来说明，这里调用的是hashMap的entrySet方法：其中，entrySet0方法中，变量entrySet在HashMap的声明如下：private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;所以e==null是成立的，entrySet()最终返回了HashMap的内部类EntrySet。接着调用了iterator方法，该方法调用了newEntryIterator方法，LinkedHashMap中对该方法进行了重写：返回的迭代器是LinkedHashMap的内部类EntryIterator：EntryIterator继承自LinkedHashMap内部抽象类：LinkedHashIterator，而只重写了next方法。该迭代器的遍历是利用LinkedHashMap的链表进行遍历。在hasNext()中，通过nextEntry != header来判断是否遍历完真个链表，因为由前面知道，该链表是个循环双向链表，遍历一遍后最终会回到header。next()方法的实现如下：其中，lastReturned保存的是最后一个返回的entry，nextEntry保存的是下一次要返回的entry。由上面也可以看出，LinkedHashMap也是会抛出ConcurrentModificationException异常的(fast-fail)。至于getKey()和getValue()是HashMap.entry中的方法，这里不再赘述。到这里，可以看出为什么LinkedHashMap的遍历是有序的，因为其是通过双向链表来遍历的，从而保证了顺序，这点与HashMap不同。 LinkedHashMap在jdk1.7和jdk1.8的区别对于jdk1.7,实际上不同版本的实现也是有些许区别的，就拿我发现的其中一点，HashMap构造方法：HashMap(int initialCapacity, float loadFactor)中对于initialCapacity初始化容量，在1.7.0_06和1.7.0_51中还是有区别的，主要是初始化容量的时机不同，但最终结果还是一样的。事实上jdk7早期版本和前面的版本是通过while循环来计算取得最小的2的n次方的数的，在jdk1.7后面的版本以及jdk8开始都是一个单独方法中计算取得最小的2的n次方的数的。比如jdk8的计算如下：通过移位来计算获取，比如14,通过移位后是15，然后判断后+1返回16。对于jdk1.8中LinkedHashMap的源码并没有花太多时间去看，只是简单浏览下。其中，jdk8中LinkedHashMap的成员变量多了tail尾结点，而通过初始化和put发现其不再是jdk7中循环双向链表，而只是一个双向链表。至于其它区别，没有细看，原理应该都差不多，其中由于HashMap在jdk8中多了红黑树的实现，所以相应的LinkedHashMap也是类似的变动。 LinkedHashMap的使用场景在前面的介绍中可以看到，LinkedHashMap是有序的，所以对于需要有序的集合会使用到LinkedHashMap。除此外，还常常被用于实现LRU缓存实现，主要是重写removeEldestEntry()。在初始化时将accessOrder设置为true并重写该方法，则调用get或put方法，对被访问的entry进行重排序，被访问的entry会被移动到链表尾，而removeEntryForKey()会移除链表头的entry：1234Entry&lt;K,V&gt; eldest = header.after;if (removeEldestEntry(eldest)) &#123; removeEntryForKey(eldest.key);&#125; 所以可以达到lru算法的目的。在mybatis的缓存模块中，有一个LruCache类(org.apache.ibatis.cache.decorators.LruCache),就是基于LinkedHashMap实现的LRU缓存，其重写了removeEldestEntry方法： 总结1、LinkedHashMap继承与HashMap，所以大部分方法跟HashMap类似，包括扩容的大小等。LinkedHashMap是HashMap+双向链表的实现；2、LinkedHashMap中的所有方法没有被synchronized修饰，所以LinkedHashMap是非线程安全的，在遍历中对元素进行移除或者添加操作是可能抛出ConcurrentModificationException异常的。3、LinkedHashMap是有序的，在初始化时通过设置accessOrder可以控制其是按照插入的顺序排序还是根据访问顺序排序。","categories":[],"tags":[],"keywords":[]},{"title":"浅谈HashMap","slug":"浅谈HashMap","date":"2019-05-19T03:54:29.000Z","updated":"2019-05-19T07:50:16.011Z","comments":true,"path":"2019/05/19/浅谈HashMap/","link":"","permalink":"http://yoursite.com/2019/05/19/浅谈HashMap/","excerpt":"","text":"版本jdk1.7.0_06 引入​ HashMap是java中常用的集合类之一，几乎每个程序员都知道它，也会在不经意间使用到它。HashMap常会被用来与Hashtable和ConcurrentHashMap作比较。在弄清它们的区别前，首先应该了解下各个类底层究竟是怎么实现的。本文就来谈谈HashMap的实现原理。 ​ HashMap在jdk1.7和jdk1.8的实现上有较大的不同，本文仅针对jdk1.7（jdk7不同的小版本细节上也有些不同）来谈论，关于HashMap在jdk1.8下的实现将在之后有空补充。 关系 HashMap的继承关系如下： 123public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable HashMap继承自AbstractMap，同时实现了Map、Cloneable和Serializable接口。因此，HashMap支持序列化(Serializable只是个标注性接口，并没有任何方法。实际上jdk提供的大部分类都实现了这个接口)，HashMap可以被克隆(Cloneable也是一个标注性的接口，具体clone()是Object类的方法，需要自行重写以实现对应类的clone) 属性先来简单了解下HashMap里的几个变量： 12345678static final int DEFAULT_INITIAL_CAPACITY = 16;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;transient Entry[] table;transient int size;int threshold;final float loadFactor;transient int modCount; DEFAULT_INITIAL_CAPACITY：默认初始化大小为16，这里主要是用在初始化Entry数组的大小； MAXIMUM_CAPACITY：hashmap最大限制容量 DEFAULT_LOAD_FACTOR：默认负载因子，默认0.75，主要是用于扩容的判断的，后面扩容时会详细说明； table：是存储主要数据的数组，每一个又称为槽(bucket)，初始默认数组大小为16(DEFAULT_INITIAL_CAPACITY 决定)，每一个槽又是一个链表的头结点。 size：HashMap实际存储键值对的数量； threshold：threshold = capacity * loadFactor，是判断是否需要扩容的阈值。 loadFactor：实际负载因子，若没有自己赋值，则默认loadFactor=DEFAULT_LOAD_FACTOR； modCount：主要是用在fast-fail机制的判断，这里可暂时不理会。在进行迭代时该参数有重要作用。可能有些参数还不是很理解，可暂时放下，后面在解释HashMap具体方法的时候可能会好理解些。 存储结构在继续往下理解之前，先来了解下HashMap底层是怎么存储数据的。 在上面的属性中可以看到hashmap有一个Entry类数组，那么Entry具体是个怎么样的结构呢？ 1transient Entry[] table; 通过源码看到，Entry是HashMap的一个静态内部类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; final int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; public final int hashCode() &#123; return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); &#125; public final String toString() &#123; return getKey() + \"=\" + getValue(); &#125; /** * This method is invoked whenever the value in an entry is * overwritten by an invocation of put(k,v) for a key k that's already * in the HashMap. */ void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; /** * This method is invoked whenever the entry is * removed from the table. */ void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125; &#125; 可以看到Entry主要有四个属性，其中一个属性仍然为Entry(Entry&lt;K,V&gt; next),这其实可以说是链表的一个实现方式。 HashMap是通过数组+链表的方式存储键值对的，通过计算key的哈希值得到键值对在Entry数组(bucket)的位置，如果这个位置上已经存在其他键值对了，即产生哈希冲突，则会采用拉链法进行存储。所以每个Entry数组元素实际上是一个单链表头。 构造方法大概知道了HashMap的存储结构后，来看看HashMap的构造方法。 HashMap提供了4个构造方法 1234public HashMap()public HashMap(int initialCapacity)public HashMap(Map&lt;? extends K, ? extends V&gt; m)public HashMap(int initialCapacity, float loadFactor) 逐一来看： public HashMap() 源码如上，当调用hashmap的无参构造方法时，其会调用public HashMap(int initialCapacity, float loadFactor)，自动为HashMap初始化一些默认值，包括当前负载因子默认为0.75，Entry数组的大小为16，即默认16个槽(bucket),(这里16是2的4次方，实际上HashMap在扩容时也会使大小为2的n次方，关于原因会在后面解释)，threshold仍然按公式计算=0.75*16=12；即当size&gt;12时就会进行扩容操作。为什么是大于12而不是16呢？主要是因为HashMap底层的存储方式影响的。因为HashMap底层是采用hash函数来决定每一个键值对存放在哪个槽的，而我们知道，当键值对的数量越接近与槽的数量，则出现冲突的可能性就会越大，这样效率反而低下，所以这里设置了负载因子和threshold用于判断扩容的时机。 public HashMap(int initialCapacity) 从源码知，该方法调用了另一个构造方法。传入的参数中，第一个为我们指定的容量大小，第二个为负载因子，使用默认的0.75. public HashMap(int initialCapacity, float loadFactor) 这是该构造方法的源码，可以看到，前三个if都是对传入的参数大小类型等进行判断。如果指定的大小超出限制的最大容量，则直接让初始化大小等于限制的最大容量。 后面的这段代码： 123int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; 则是通过循环找到第一个大于指定的initialCapacity的且是2的n次方的数。capacity &lt;&lt;= 1指相左移一位，相当于乘以2，以此方法得到的数，都可以通过2的n次方得到。为什么一定要使用2的n次方而不直接使用我们构造时传入的容量参数呢？后面会解释。得到具体的容量capacity后，即可通过负载因子和capacity计算出threshold，而Entry数组的大小也就可以初始化了。这里init()方法是个空方法。 在这里init方法并没有什么用，但是其它继承HashMap的集合类可重写该方法。在linkedHashMap可看到重写了这个方法。 public HashMap(Map&lt;? extends K, ? extends V&gt; m)很明显，这个构造方法是打算使用另一个map的数据来构造一个新的HashMap，其源码如下：很明显，调用的仍然是上面的构造方法，但是传入的槽的大小这个参数却是由构造这个HashMap时传入的m的大小. 1(m.size() / DEFAULT_LOAD_FACTOR) + 1 指的是刚好达到需要扩容的这个原数组的大小，如果这个数比16小，则仍然使用默认的16。 在初始化完成后，在调用putAllForCreate方法将m的各个数据存放进去。通过putForCreat方法将e散列到对应的bucket中。putForCreate方法调用indexFor来确定键值对散列的bucket的位置。indexFor通过h &amp; (length-1)返回bucket的位置，接着遍历对应的单链表来决定是更新操作还是插入操作。(与put方法部分类似，可参考后面). put方法下面来分析put(K key, V value)方法。该方法的源码如下： 首先判断key值是否为null，如果是，则调用putForNullKey方法。putForNullKey方法的实现如下： 可以清楚的看到，这for中指定了使用table[0],即null key总是存放在Entry[]数组的第一个元素。再接下来的if语句中，则是判断是否已经存放了key为null的键值对，如果存在，则替换其value，并放回旧值，所以HashMap中只可能存在一个key为null键值对。如果不存在，则调用addEntry方法来设置Entry数组的第一个元素的内容:一个key为null,值为value的值。(这里modCount++主要是在迭代过程中fast-fail机制中使用，这里暂时都忽略它)，继续跟进去addEntry方法： 可以看出在这个方法主要是初始化了Entry数组的一个槽，并将传入的参数作为数据设置进去。其中， 1new Entry&lt;&gt;(hash, key, value, e) 调用的是内部类Entry的构造方法。由于table[0]可能本身就已经有其他非null数据连接成的链表，那么新增一个节点是怎么处理的呢？看看下面这个构造方法的具体实现： 从源码看到，当前table[0]指向新的Entry，而原来的则成为其next(next=n),举个例子，原先table[0]上是A-&gt;B-&gt;C,这时候有个D刚好hash后也在table[0]这个槽，所以加入后变成D-&gt;A-&gt;B-&gt;C,即当前数组元素中链表头节点所在的数据是最后插入的元素。 同时，在完成后插入新值后还要将size+1(size用来记录当前HashMap有多少个键值对)，并判断其大小是否超过了threshold(if(size++&gt;=threshold))，如果超过，则要调用方法进行扩容,扩容时传进的参数为当前数组的大小*2。关于resize扩容的具体内容，留待后面再说。暂且回到pull方法。在判断了key是否null之后，假设不为null，则计算使用key的hashcode来计算其hash值，通过这个hash方法，计算出其hash结果，然后调用indexFor方法来计算得出应该将这个key-value放在Entry数组的哪个槽上： 这个方法的解释也是在后面说明。 接着利用算出的i即在Entry数组的位置，通过for循环遍历该槽上的链表，查找是否有相同的key值，若有则覆盖旧值。 如果尚未存在这个key，则仍然通过addEntry方法插入新值。这个方法在前面说过，就不再赘述。 get方法先看看源码： 首先当然是先判断key是否为null，如果是，则调用getForNullKey方法，由上面put方法的分析，我们知道key为null的键值对都是存放在table[0]里的，所以这里不难猜测，getForNullKey方法就是从table[0]里取出数据： 如果key不为null，则先计算Key的hash值，定位到数组中对应的bucket，然后开始遍历Entry单链表， 通过对比哈希码相同并且对象(key)相同，直到找到则返回其value，否则返回null。 HashMap的扩容从上面的分析我们知道，在addEntry(int hash, K key, V value, int bucketIndex)方法中，没增加一个数据，则会对size进行判断，如果超过threshold，则会调用resize进行2倍扩容，很明显，这里扩容为原来的2倍也是满足了2的n次方。这里主要分析resize方法： 从源码看出，首先对原数组的容量oldCapacity进行判断，如果已经达到限制的最大容量MAXIMUM_CAPACITY，则不再进行扩容，令threshold = Integer.MAX_VALUE，然后返回。如果oldCapacity未超过MAXIMUM_CAPACITY，则new出一个新的Entry数组newTable，其大小为newCapacity，即为原来的2倍，然后调用transfer方法将原来的数据重新hash到新数据中去，因为数组的大小变了，则原来的数据经过hash计算后就不一定会在原来的那个位置了，所以这里需要对原来的全部数据进行重新hash计算并重新存储，当数据比较多时，这个开销还是比较大的。(这个过程一般也称rehash) 完成新数组的复制操作后，将HashMap的属性table指向新的数组newTable，然后重新计算threshold的值。至此，完成了HashMap的扩容操作。 jdk1.7和jdk1.8下HashMap比较明显的变化jdk1.7下，但链表过长时，可能就会有效率问题，如果不幸大部分数据都落在同一个bucket下，就会形成很长的链，算法就退化为O(n)的时间复杂度了，jdk1.8下hashMap增加了红黑树，即结构是数组+链表+红黑树，默认是链表长度大于8时，链表会转化为红黑树，从而提高查找效率。由于增加了红黑树，jdk1.8的hashmap源码看起来就比1.7的复杂了不少，有兴趣的可以看看哈。 为什么HashMap容量一定要为2的n次方下面就来说说前面留下的这个问题。我们知道，hashmap默认初始化时table数组大小为16，即2的4次幂，如果发生扩容，每次也是扩容2倍。并且在构造函数时，如果你指定了大小，比如指定了6，那么实际会变成8，即满足&gt;6的且是2的幂的数。那么，为什么一定要严格遵守这个呢？ 123456/** * Returns index for hash code h. */ static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; 我们知道，HashMap的存储结构是数组+单链表，当然，我们希望数据能存放的越均匀越好，链表长度越短越好，即减少冲突，可以hash找到数组就直接找到需要的数，这除了控制扩容的时机(即负载因子的选择)外，还要选择正确的hash函数，比较好的一种就是：哈希值%容量，我们看到HashMap的indexFor方法是怎么实现的，可以看到，其使用了位运算h &amp; (length-1) ，很明显，使用位运算是为了提高效率，因为机器在计算位运算时远远比计算乘除运算快得多。而HashMap在扩容时进行rehash会重新计算其位置，所以这一步的效率还是比较重要的。那么，这段h &amp; (length-1)究竟代表了什么样的运算呢?其实容量设计为2的幂主要就是与这里有关，因为2的n次方换算为二进制肯定就是1后面n个0，比如16的二进制为10000，即length-1=15即01111，而&amp;运算就是只有两个都为1，结果才为1，则此时当任意大于0小于16的数与01111进行与操作后，结果都是其本身，而当任何大于15的数与01111进行与操作后，结果相当于进行了%运算，这正是达到了前面说的比较好的hash函数。 比如：14，二进制01110，与15进行与操作：01110&amp;01111=01110，还是14； 又比如：17，二进制10001，与15进行与操作：10001&amp;01111=00001，结果为1，相当于(17-1)%(16-1)=1; (数组是从0开始的) 从某方面看，将容量设置为2的幂可能浪费了空间，比如你构造函数时只需要容量5，但是却变成了8，浪费了空间，但是从另一个角度看，却也节省了空间，比如：假设HashMap的容量不遵循2的n次幂，比如为15时，此时不为2的n次幂，其二进制01111，length-1后等于01110，则此时不论h为什么，h&amp;(length-1)得到的二进制结果末尾是不可能为1的，因为&amp;操作要求两个都为1，结果才为1，而这里length-1结果为01110，很明显已经不满足这个条件了，所以此时Entry数组的某些槽如：0001，0011，0101，1001，1011，0111，1101却永远无法存放数据了，这在一定程度上浪费了空间。这样导致的结果是，会增加发生冲突的可能性，进而减慢了查询。 关于Hashtable和HashMap的区别区别1：HashMap允许key和value为null，但仅允许一个key为的null，而Hashtable不允许key或value为null； HashMap的这一点，在上面我们已经看出了，但有key为null多个时，会替换旧的key为null的值，所以仅可能存在一个，并且HashMap对value没有null的限制；关于Hashtable的这一点，我们可以通过源码说明： 而在HashMap中，在求key.hashCode前会对key进行null的判断，若为null，则调用putForNullKey方法，此时将hash值设置为0，具体通过源码即可知； 区别2：HashMap是非线程安全的，而Hashtable是线程安全的； Hashtable的线程安全主要体现在它的大部分方法都是加了 sychronized的： 区别3：由于HashMap是没有加锁的，自然HashMap在效率上会比Hashtable好一些； 区别4：Hashtable使用 enumerator迭代器，HashMap使用 Iterator迭代器， Iterator是 fail-fast迭代器，即在迭代过程中，如果有其他线程增加或者移除了集合中的元素，则会抛出 ConcurrentModificationException异常; 区别5：继承的父类不同，Hashtable继承了Dictionary，而HashMap 继承了AbstractMap; 但二者都实现了Map接口。 区别6：HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。 Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。containsValue和containsKey的源码很简单，有兴趣可以自己查看。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"},{"name":"扩容","slug":"扩容","permalink":"http://yoursite.com/tags/扩容/"},{"name":"HashMap","slug":"HashMap","permalink":"http://yoursite.com/tags/HashMap/"}],"keywords":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}]},{"title":"继承和组合的区别","slug":"继承和组合的区别","date":"2019-05-04T07:47:02.950Z","updated":"2019-05-04T07:47:02.950Z","comments":true,"path":"2019/05/04/继承和组合的区别/","link":"","permalink":"http://yoursite.com/2019/05/04/继承和组合的区别/","excerpt":"","text":"什么是继承继承是面向对象三大基本特征之一(继承，封装，多态)，继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。在java中通过关键字extends实现继承，java中所有类默认都是java.lang.Object的子类。继承强调的是is-a关系。直接通过例子来了解继承： 12345678/** * 动物 */public class Animal &#123; public void breathing() &#123; System.out.println(\"呼气...吸气...\"); &#125;&#125; 123456789101112131415/** * 飞行动物 * 继承 */public class FlyingAnimals extends Animal&#123; public void filying() &#123; System.out.println(\"飞行...\"); &#125; public static void main(String[] args) &#123; FlyingAnimals flyingAnimals = new FlyingAnimals(); flyingAnimals.breathing(); flyingAnimals.filying(); &#125;&#125; 运行结果： 呼气…吸气…飞行… 继承是代码复用的一种方式。在继承中，父类的方法内部实现细节对子类可见，是‘白盒式’的代码复用。 什么是组合组合是通过对现有对象进行拼装即组合产生新的具有更复杂的功能。如： 12345678/** * 动物 */public class Animal &#123; public void breathing() &#123; System.out.println(\"呼气...吸气...\"); &#125;&#125; 123456789101112131415161718192021222324252627/** * 爬行动物 * 组合 */public class Reptilia &#123; private Animal animal; public Reptilia(Animal animal) &#123; this.animal = animal; &#125; public void crawling() &#123; System.out.println(\"爬行...\"); &#125; public void breathing() &#123; animal.breathing(); &#125; public static void main(String[] args) &#123; Animal animal = new Animal(); Reptilia reptilia = new Reptilia(animal); reptilia.breathing();; reptilia.crawling(); &#125;&#125; 运行结果： 呼气…吸气…爬行… 组合体现的是整体和部分，强调的是has-a的关系。所以组合更多的用于下面这样的场景： 12345678910111213141516/** * 轮胎 */class Tire &#123; public void run() &#123; System.out.println(\"轮胎转动...\"); &#125;&#125;/** * 车灯 */class Light &#123; public void light() &#123; System.out.println(\"灯亮...\"); &#125;&#125; 12345678910111213141516171819202122232425/** * 交通工具 * 组合 */public class Vehicle &#123; private Tire tire; private Light light; public Vehicle(Tire tire,Light light) &#123; this.tire = tire; this.light = light; &#125; public void operation() &#123; light.light(); tire.run(); &#125; public static void main(String[] args) &#123; Tire tire = new Tire(); Light light = new Light(); Vehicle vehicle = new Vehicle(tire,light); vehicle.operation(); &#125;&#125; 运行结果： 灯亮…轮胎转动… 继承与组合的区别与联系继承与组合都是面向对象中代码复用的方式。父类的内部细节对子类可见，其代码属于白盒式的复用，而组合中，对象之间的内部细节不可见，其代码属于黑盒式复用。继承在编码过程中就要指定具体的父类，其关系在编译期就确定，而组合的关系一般在运行时确定。继承强调的是is-a的关系，而组合强调的是has-a的关系。 继承与组合的优缺点继承的优缺点优点： 支持扩展，通过继承父类实现，但会使系统结构较复杂 易于修改被复用的代码缺点： 代码白盒复用，父类的实现细节暴露给子类，破坏了封装性 当父类的实现代码修改时，可能使得子类也不得不修改，增加维护难度。 子类缺乏独立性，依赖于父类，耦合度较高 不支持动态拓展，在编译期就决定了父类组合的优缺点优点： 代码黑盒复用，被包括的对象内部实现细节对外不可见，封装性好。 整体类与局部类之间松耦合，相互独立。 支持扩展 每个类只专注于一项任务 支持动态扩展，可在运行时根据具体对象选择不同类型的组合对象(扩展性比继承好)缺点： 创建整体类对象时，需要创建所有局部类对象。导致系统对象很多。 什么情况下使用继承，什么情况下使用组合从前面的分析看，组合的优点明显多于继承，再加上java中仅支持单继承，所以：除非两个类之间是is-a的关系，否则尽量使用组合。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"继承","slug":"继承","permalink":"http://yoursite.com/tags/继承/"},{"name":"组合","slug":"组合","permalink":"http://yoursite.com/tags/组合/"}],"keywords":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}]},{"title":"java中的代理模式（Proxy）","slug":"java中的代理模式（proxy）","date":"2019-05-04T07:47:02.943Z","updated":"2019-05-04T07:47:02.943Z","comments":true,"path":"2019/05/04/java中的代理模式（proxy）/","link":"","permalink":"http://yoursite.com/2019/05/04/java中的代理模式（proxy）/","excerpt":"","text":"代理模式介绍什么是代理模式代理模式：为其他对象提供一种代理以控制对这个对象的访问；代理模式的好处：在目标对象的基础上，去添加额外的功能操作，而不修改原先的业务方法。让业务方法去专注于自己的业务逻辑。代理模式让我们可以去扩展目标对象的功能。通俗点，就是有个代理人去帮我们处理琐碎的事情。 代理模式的分类代理模式主要分为:1、静态代理：由工具或者开发者手动生成代理源代码，并对其进行编译成.class，这种方式，在运行前.class文件就已经存在了。不够灵活。2、动态代理：在程序运行时，通过运用反射机制动态生成.class。（1） jdk动态代理：代理所有“实现的有接口”的目标类（2） cglib动态代理：代理任意一个目标类，但对final类和方法无法代理 静态代理模式的uml图典型的静态的代理模式uml图如下：主要的角色：Subject：抽象主题角色，负责定义RealSubject(目标对象)和Proxy(代理对象)角色应该实现的接口RealSubject：具体主题角色，即被代理对象，用来真正完成业务服务功能Proxy：代理主题角色，委托类，负责将自身的Request请求，调用realsubject 对应的request功能来实现业务功能，自己不真正做业务。 静态代理先来定义两个类：UserService和UserServiceImpl 12345678/** * 接口 * @author hongwu * */public interface UserService &#123; void save();&#125; 1234567891011121314/** * 对象 * 代理目标对象 * @author hongwu * */public class UserServiceImpl implements UserService&#123; @Override public void save() &#123; System.out.println(\"保存操作...\"); &#125;&#125; 下面的几个例子都将使用这两个类来举例。先来看看静态代理的例子： 123456789101112131415161718192021222324252627package com.howard.demo.proxy.staticproxy;import com.howard.demo.proxy.UserService;/** * 静态代理 * @author hongwu * */public class UserServiceProxy implements UserService&#123; private UserService target; public UserServiceProxy(UserService target) &#123; super(); this.target = target; &#125; @Override public void save() &#123; System.out.println(\"操作前的预处理...\"); target.save(); System.out.println(\"操作后的处理...\"); &#125;&#125; 123456789101112/** * 静态代理测试类 * @author hongwu * */public class Test &#123; public static void main(String[] args) &#123; UserService target = new UserServiceImpl(); UserServiceProxy proxy = new UserServiceProxy(target); proxy.save(); &#125;&#125; 运行结果： 操作前的预处理…保存操作…操作后的处理… 静态代理可以在不修改目标对象代码的前提下，对目标对象功能进拓展，但是，由于静态代理对每一个被代理对象都要编写一个代理类，一旦有很多需要被代理的对象时，就要写很多代理类，所以就有了动态代理的方式。 动态代理动态代理是指在运行时，动态生成代理类。即，代理类的字节码将在运行时生成并载入当前的ClassLoader。动态代理的实现方式主要有两种，一种是使用jdk自带的对于动态代理的支持，一种是使用cglib的方式。 jdk对于动态代理的支持jdk的动态代理是基于接口的。主要使用Proxy的静态方法和创建一个类实现 InvocationHandler接口，通过重写invoke)()方法来完成。 12345public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) public Object invoke(Object proxy, Method method, Object[] args) throws Throwable 主要做了以下几个工作：1、获取RealSubject上的所有接口；2、确定要生成的代理类的类名，默认为com.sun.proxy.$ProxyXXX;3、根据需要实现的接口信息，在代码中动态创建该Proxy类的字节码；4、将对应的字节码转换为对应的class对象；5、创建InvocationHandler实例实现handler，处理Proxy的所有方法调用。6、Proxy的class对象以创建的handler对象为参数，实例化一个proxy对象。例子： 1234567891011121314151617181920212223242526272829/** * jdk 动态代理 * @author hongwu * */public class JDKProxy implements InvocationHandler&#123; //被代理类 private Object target; //Object 可以接受不同的代理类 public Object getInstance(Object target) &#123; this.target = target; //Object java.lang.reflect.Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) //注意这里创建代理对象时传入的第二个参数是代理对象的接口对象 jdk的proxy代理只能代理接口对象，所以被代理类都必须有实现接口 return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object obj = null; System.out.println(\"操作前的预处理...\"); obj = method.invoke(target, args); System.out.println(\"操作后的处理...\"); return obj; &#125;&#125; 测试： 1234567891011public class Test &#123; public static void main(String[] args) &#123; //打开这个配置 可以把生成$Proxy0的class文件保存下来 //System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\"); //只能代理接口对象 UserService service = (UserService) new JDKProxy().getInstance(new UserServiceImpl()); System.out.println(service.getClass().getName()); //com.sun.proxy.$Proxy0 service.save(); &#125;&#125; 运行后可以看到： com.sun.proxy.$Proxy0操作前的预处理…保存操作…操作后的处理… 可以看到，返回的UserService是一个代理对象：$Proxy0为了可以看看这个代理对象究竟是怎样的一个类，可以打开注释掉的那个配置，是生成的class文件保存到本地： 1System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\"); 运行后会发现生成的$Proxy0的class文件，使用反编译工具进行查看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.sun.proxy;import com.howard.demo.proxy.UserService;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements UserService&#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; public $Proxy0(InvocationHandler paramInvocationHandler) throws &#123; super(paramInvocationHandler); &#125; public final boolean equals(Object paramObject) throws &#123; try &#123; return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void save() throws &#123; try &#123; this.h.invoke(this, m3, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)this.h.invoke(this, m2, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)this.h.invoke(this, m0, null)).intValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] &#123; Class.forName(\"java.lang.Object\") &#125;); m3 = Class.forName(\"com.howard.demo.proxy.UserService\").getMethod(\"save\", new Class[0]); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125;&#125; 可以看到该类继承自 java.lang.reflect.Proxy，里面所有的方法都是final的，并且方法内部功能的实现都统一调用了InvocationHandler的invoke()方法。所以动态代理与反射是有很大关系的。但是jdk实现的动态代理有一个缺点，那就是被代理的对象都必须有实现的接口，所以生成的代理类也只能代理该接口定义的方法。而cglib动态代理就不会有这个问题。 cglib实现动态代理cglib(Code Generation Library)实现动态代理是基于ASM框架实现的，需要cglib和asm两个jar包。maven下导入下面的依赖默认asm也会加入： 123456&lt;!-- cglib --&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; cglib代理，,也叫作子类代理，它是在内存中构建一个子类对象并覆盖其中方法实现增强，从而实现对目标对象功能的扩展.，但因为采用的是继承，所以不能对final修饰的类进行代理。CGLIB创建某个类A的动态代理类的模式是：1、查找A上的所有非final的public类型的方法定义2、将这些方法的定义转换成字节码3、将组成的字节码转换成相应的代理的class对象4、实现MethodInterceptor接口，用来处理对代理类上所有方法的请求（这个接口和Jdk动态代理InvocationHandler的功能和角色是一样的）cglib动态代理的核心类是：Enhancer，它负责代理对象的生命周期，提供很多方法来帮助我们完成代理实例的创建。其中最主要的两个方法是： 123public void setSuperclass(Class superclass) ；//设置父类，即传入代理对象//设置了回调。也就是将来对我们代理中方法的访问会转发到该回调中，所有自定义的回调类必须继承MethodInterceptor接口并实现其intercept方法，这一点和jdk的InvocationHandler类似。public void setCallback(final Callback callback)； MethodInterceptor接口的intercept方法： 1public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable 其中，proxy指被代理的对象，method指调用的当前方法，args指方法的参数集合，methodProxy被调用方法的代理，它可以和method完成同样的事情，但是它使用FastClass机制非反射执行方法，效率比较高。下面看看具体使用的例子： 12345678910111213141516171819202122232425262728/** * cglib动态代理 * @author hongwu * */public class CglibProxy implements MethodInterceptor&#123; private Object target; public Object getInstance(Object target) &#123; this.target = target; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(target.getClass()); enhancer.setCallback(this); Object proxy = enhancer.create(); return proxy; &#125; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; Object obj = null; System.out.println(\"操作前的预处理...\"); obj = method.invoke(target, args); System.out.println(\"操作后的处理...\"); return obj; &#125;&#125; 测试： 123456789public class Test &#123; public static void main(String[] args) &#123; //可以代理对象 UserServiceImpl service = (UserServiceImpl) new CglibProxy().getInstance(new UserServiceImpl()); //获取到的是代理对象 com.howard.test.proxy.UserServiceImpl$$EnhancerByCGLIB$$6aa6fa4f System.out.println(service.getClass().getName()); service.save(); &#125;&#125; 运行结果： com.howard.demo.proxy.UserServiceImpl$$EnhancerByCGLIB$$3bd67ffa操作前的预处理…保存操作…操作后的处理… sping aop的代理默认是使用jdk的代理方式，如果需要使用cglib，需加上配置： 1&lt;aop:aspectj-autoproxy proxy-target-class=\"true\"&gt; 该配置默认是false","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"代理","slug":"代理","permalink":"http://yoursite.com/tags/代理/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/动态代理/"},{"name":"cglib","slug":"cglib","permalink":"http://yoursite.com/tags/cglib/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-04T07:47:02.941Z","updated":"2019-05-04T07:47:02.941Z","comments":true,"path":"2019/05/04/hello-world/","link":"","permalink":"http://yoursite.com/2019/05/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"test","slug":"my-test","date":"2018-10-26T07:38:50.000Z","updated":"2019-05-19T02:56:57.835Z","comments":true,"path":"2018/10/26/my-test/","link":"","permalink":"http://yoursite.com/2018/10/26/my-test/","excerpt":"","text":"2019-05-19","categories":[],"tags":[],"keywords":[]},{"title":"优雅的点","slug":"优雅的点","date":"2018-08-31T13:07:49.000Z","updated":"2019-05-04T07:47:02.947Z","comments":true,"path":"2018/08/31/优雅的点/","link":"","permalink":"http://yoursite.com/2018/08/31/优雅的点/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.howard.algorithm; import java.util.Scanner;/** * 优雅的点 * 时间限制：1秒 * 空间限制：32768K * 小易有一个圆心在坐标原点的圆，小易知道圆的半径的平方。小易认为在圆上的点而且横纵坐标都是整数的点是优雅的，小易现在想寻找一个算法计算出优雅的点的个数，请你来帮帮他。 * 例如：半径的平方如果为25 * 优雅的点就有：(+/-3, +/-4), (+/-4, +/-3), (0, +/-5) (+/-5, 0)，一共12个点。 * 输入描述:输入为一个整数，即为圆半径的平方,范围在32位int范围内。 * 输出描述:输出为一个整数，即为优雅的点的个数 * 输入例子1:25 * 输出例子1:12 * 2017年8月12日 * @author howard */public class BeautifulPoint &#123; public static void main(String[] args) &#123;// System.out.println(findBeautifulPoint(16)); Scanner str = new Scanner(System.in); int num = str.nextInt(); int count = 0; //数（+-x,+-y）等于4个点 for (int i = 0 ; i*i &lt;= num; i ++ ) &#123; //只取比i大的 找到一对数（x,y）则为4*2 for (int j = i ; j * i &lt;= num; j ++ ) &#123; if ((i * i) + (j * j) &gt; num) &#123; break; &#125; if ((i * i) + (j * j) == num) &#123; //+-0 一样 if (i == 0 || j == 0) &#123; count += 4; &#125;else if( i == j)&#123; count += 4; &#125;else &#123; count += 8; &#125; break; &#125; &#125; &#125; System.out.println(count); str.close(); &#125;&#125; 运行结果：","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/categories/算法与数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"笔试","slug":"笔试","permalink":"http://yoursite.com/tags/笔试/"}],"keywords":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/categories/算法与数据结构/"}]},{"title":"抽象类与接口的区别","slug":"抽象类与接口的区别","date":"2018-07-31T04:54:00.000Z","updated":"2019-05-04T07:47:02.948Z","comments":true,"path":"2018/07/31/抽象类与接口的区别/","link":"","permalink":"http://yoursite.com/2018/07/31/抽象类与接口的区别/","excerpt":"","text":"什么是抽象类在java中，使用abstract修饰的类就是一个抽象类。如下就是一个抽象类： 1234567891011121314151617181920212223242526/** * 抽象类 */public abstract class A &#123; /** * 抽象类中可以有成员变量，可以有常量 */ private int a; public int b; int c; String str; public static final String STR = \"abstract\"; //抽象类中可以有构造方法 public A() &#123; &#125; public void funA() &#123; System.out.println(\"抽象类中可以有普通方法\"); &#125; //抽象方法 abstract void funB();&#125; 抽象类可以有成员变量，可以有常量，可以有构造方法，可以有普通方法(包括静态方法)，只要是普通的类中可以有的，抽象方法都可以有。但还是需要注意几点： 抽象类不可以被实例化，即使抽象类有构造方法，但在抽象类中可以有构造方法，只是不能直接创建抽象类的实例对象。在实例化子类的时候，就会初始化父类，不管父类是不是抽象类都会调用父类的构造方法，此时如果是抽象类就会调用抽象类的构造方法； 方法被abstract修饰后，该方法即为抽象方法，此时该方法无方法体，即不能加{}进行实现，且该方法不能再加private、final进行修饰； 抽象类中可以没有抽象方法，但类中只要存在一个抽象方法，该类即为抽象类，不能被实例化； 继承抽象类的子类可以是普通类，如果为普通类，则必须重写抽象类中所有的抽象方法，只要有一个没重写(仍为抽象方法)，则该子类仍为抽象方法。 抽象类不能被final修饰。因为final修饰的类无法被继承 抽象类不能被static修饰，但内部抽象类可以 12345678910111213141516171819202122public abstract class F &#123; abstract static class G &#123; abstract void funGA(); &#125; abstract void funA(); &#125;//继承内部抽象类class H extends F.G &#123; @Override void funGA() &#123; System.out.println(\"实现F.G抽象类中的方法\"); &#125; public static void main(String[] args) &#123; F.G g = new H(); g.funGA(); &#125;&#125; 运行结果： 实现F.G抽象类中的方法 什么是接口在java中，接口使用interface修饰，接口是一种规范，是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。如下就是一个接口： 12345678910111213141516/** * 接口 */public interface B &#123; //接口里可以有常量。默认都是加了public final static //由于是常量，所以必须初始化 //通过接口名.常量访问 如B.a int a = 2; public final static String str = \"interface\"; //接口中的方法默认都是public abstract修饰 void funA(); public abstract void funB();&#125; 接口可以说是一中特殊的抽象类，接口里的方法都是抽象方法(默认使用了public abstract修饰)。 子类实现接口必须实现接口中的所有方法； 接口中不能有成员变量，只能有常量，即默认都是public final static修饰； 接口不能被实例化； 接口不能有构造方法； 接口可以继承接口，使用extends并且可以继承多个接口： 1234567interface C extends B &#123; int aa = 3;&#125;interface D extends B,C &#123; int dd = 4;&#125; jdk1.8中，接口允许有静态方法（用static修饰），也允许接口有默认实现（用default修饰）。子类实现接口时可以不重写 default修饰的方法。也可以重写覆盖。 1234567891011121314151617181920212223242526272829303132333435363738class E implements D &#123; @Override public void funA() &#123; System.out.println(\"实现接口A\"); &#125; @Override public void funB() &#123; System.out.println(\"实现接口B\"); &#125; /*@Override public void funD() &#123; System.out.println(\"覆盖默认实现\"); &#125;*/ public static void main(String[] args) &#123; E e = new E(); System.out.println(\"访问接口B中的常量...\"); //访问接口B中的常量 System.out.println(B.a); System.out.println(E.a); System.out.println(C.a); //接口中的静态方法 System.out.println(\"访问接口中的静态方法...\"); B.funC(); System.out.println(\"访问类E中重写接口的方法...\"); e.funA(); e.funB(); System.out.println(\"访问接口中的默认方法...\"); e.funD(); &#125;&#125; 运行结果： 访问接口B中的常量…222访问接口中的静态方法…jdk1.8新增的接口中的静态方法访问类E中重写接口的方法…实现接口A实现接口B访问接口中的默认方法…jdk1.8新增的接口中的默认方法实现 抽象类和接口的区别 抽象类和接口都不能实例化 抽象类和接口中的抽象方法都只能有方法声明，不能有方法体（jdk1.8后接口中的默认方法可以有方法体） 抽象类和接口的概念有所不同，抽象类是对根源的抽象，接口是对动作的抽象。通俗点讲就是，抽象类常用于表示这个对象是什么，而接口表示的是这个对象能做什么。 继承抽象类的子类可以不必实现全部抽象方法，此时该子类仍为抽象类；而实现接口的类则必须实现全部的方法(jdk1.8后新特性的默认方法除外) 类只能单继承，接口可以继承接口，并且可以多继承 接口是设计的结果 ，抽象类是重构的结果 抽象类可以有构造方法，接口不能有构造方法 抽象类中的变量没有要求，而接口中的变量必须是public static final即常量抽象类和接口的使用场景 在既需要统一的接口，又需要实例变量来协调或标记状态等情况下，可以使用抽象类； 不想要每个实现类都重写所有的抽象方法的情况下可以使用抽象类； 类与类之间关系比较紧密且需要共享代码或方法，考虑使用抽象类； 仅强调动作，而不在乎其如何实现，考虑使用接口； 需要实现特定的多项功能，且功能之间无比较紧密的联系，考虑使用接口； 参考链接：抽象类和接口的使用场景介绍&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接口和抽象类有什么区别","categories":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"},{"name":"抽象类","slug":"抽象类","permalink":"http://yoursite.com/tags/抽象类/"},{"name":"接口","slug":"接口","permalink":"http://yoursite.com/tags/接口/"}],"keywords":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}]},{"title":"java中的fail-fast(快速失败)机制","slug":"java中的fail-fast(快速失败)机制","date":"2017-10-30T08:38:06.000Z","updated":"2019-05-04T07:47:02.943Z","comments":true,"path":"2017/10/30/java中的fail-fast(快速失败)机制/","link":"","permalink":"http://yoursite.com/2017/10/30/java中的fail-fast(快速失败)机制/","excerpt":"","text":"引入在前面介绍浅谈ArrayList动态扩容时对于modCount的操作没有详细说明，该变量的操作在add，remove等操作中都会发生改变。那么该变量到底有什么作用呢？ 简介fail-fast 机制，即快速失败机制，是java集合(Collection)中的一种错误检测机制。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast，即抛出ConcurrentModificationException异常。fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug。 fail-fast的出现场景在我们常见的java集合中就可能出现fail-fast机制,比如ArrayList，HashMap。在多线程和单线程环境下都有可能出现快速失败。 1. 单线程环境下的fail-fastArrayList发生fail-fast例子： 123456789101112131415public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0 ; i &lt; 10 ; i++ ) &#123; list.add(i + \"\"); &#125; Iterator&lt;String&gt; iterator = list.iterator(); int i = 0 ; while(iterator.hasNext()) &#123; if (i == 3) &#123; list.remove(3); &#125; System.out.println(iterator.next()); i ++; &#125;&#125; 该段代码定义了一个Arraylist集合，并使用迭代器遍历，在遍历过程中，刻意在某一步迭代中remove一个元素，这个时候，就会发生fail-fast。HashMap发生fail-fast： 12345678910111213141516public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); for (int i = 0 ; i &lt; 10 ; i ++ ) &#123; map.put(i+\"\", i+\"\"); &#125; Iterator&lt;Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); int i = 0; while (it.hasNext()) &#123; if (i == 3) &#123; map.remove(3+\"\"); &#125; Entry&lt;String, String&gt; entry = it.next(); System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); i++; &#125;&#125; 该段代码定义了一个hashmap对象并存放了10个键值对，在迭代遍历过程中，使用map的remove方法移除了一个元素，导致抛出了ConcurrentModificationException异常： 2. 多线程环境下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class FailFastTest &#123; public static List&lt;String&gt; list = new ArrayList&lt;&gt;(); private static class MyThread1 extends Thread &#123; @Override public void run() &#123; Iterator&lt;String&gt; iterator = list.iterator(); while(iterator.hasNext()) &#123; String s = iterator.next(); System.out.println(this.getName() + \":\" + s); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; super.run(); &#125; &#125; private static class MyThread2 extends Thread &#123; int i = 0; @Override public void run() &#123; while (i &lt; 10) &#123; System.out.println(\"thread2:\" + i); if (i == 2) &#123; list.remove(i); &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; i ++; &#125; &#125; &#125; public static void main(String[] args) &#123; for(int i = 0 ; i &lt; 10;i++)&#123; list.add(i+\"\"); &#125; MyThread1 thread1 = new MyThread1(); MyThread2 thread2 = new MyThread2(); thread1.setName(\"thread1\"); thread2.setName(\"thread2\"); thread1.start(); thread2.start(); &#125;&#125; 启动两个线程，分别对其中一个对list进行迭代，另一个在线程1的迭代过程中去remove一个元素，结果也是抛出了java.util.ConcurrentModificationException fail-fast的原理fail-fast是如何抛出ConcurrentModificationException异常的，又是在什么情况下才会抛出?我们知道，对于集合如list，map类，我们都可以通过迭代器来遍历，而Iterator其实只是一个接口，具体的实现还是要看具体的集合类中的内部类去实现Iterator并实现相关方法。这里我们就以ArrayList类为例。在ArrayList中，当调用list.iterator()时，其源码是： 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 即它会返回一个新的Itr类，而Itr类是ArrayList的内部类，实现了Iterator接口，下面是该类的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * An optimized version of AbstractList.Itr */private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 其中，有三个属性： 123int cursor; // index of next element to returnint lastRet = -1; // index of last element returned; -1 if no suchint expectedModCount = modCount; cursor是指集合遍历过程中的即将遍历的元素的索引，lastRet是cursor -1，默认为-1，即不存在上一个时，为-1，它主要用于记录刚刚遍历过的元素的索引。expectedModCount这个就是fail-fast判断的关键变量了，它初始值就为ArrayList中的modCount。（modCount是抽象类AbstractList中的变量，默认为0，而ArrayList 继承了AbstractList ，所以也有这个变量，modCount用于记录集合操作过程中作的修改次数，与size还是有区别的，并不一定等于size）我们一步一步来看： 123public boolean hasNext() &#123; return cursor != size;&#125; 迭代器迭代结束的标志就是hasNext()返回false，而该方法就是用cursor游标和size(集合中的元素数目)进行对比，当cursor等于size时，表示已经遍历完成。接下来看看最关心的next()方法，看看为什么在迭代过程中，如果有线程对集合结构做出改变，就会发生fail-fast： 123456789101112@SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; 从源码知道，每次调用next()方法，在实际访问元素前，都会调用checkForComodification方法，该方法源码如下： 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 可以看出，该方法才是判断是否抛出ConcurrentModificationException异常的关键。在该段代码中，当modCount != expectedModCount时，就会抛出该异常。但是在一开始的时候，expectedModCount初始值默认等于modCount，为什么会出现modCount != expectedModCount，很明显expectedModCount在整个迭代过程除了一开始赋予初始值modCount外，并没有再发生改变，所以可能发生改变的就只有modCount，在前面关于ArrayList扩容机制的分析中，可以知道在ArrayList进行add，remove，clear等涉及到修改集合中的元素个数的操作时，modCount就会发生改变(modCount ++),所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使modCount发生变化，这样在checkForComodification方法中就会抛出ConcurrentModificationException异常。类似的，hashMap中发生的原理也是一样的。 避免fail-fast了解了fail-fast机制的产生原理，接下来就看看如何解决fail-fast 方法1在单线程的遍历过程中，如果要进行remove操作，可以调用迭代器的remove方法而不是集合类的remove方法。看看ArrayList中迭代器的remove方法的源码： 1234567891011121314public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125; 可以看到，该remove方法并不会修改modCount的值，并且不会对后面的遍历造成影响，因为该方法remove不能指定元素，只能remove当前遍历过的那个元素，所以调用该方法并不会发生fail-fast现象。该方法有局限性。例子： 123456789101112131415public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0 ; i &lt; 10 ; i++ ) &#123; list.add(i + \"\"); &#125; Iterator&lt;String&gt; iterator = list.iterator(); int i = 0 ; while(iterator.hasNext()) &#123; if (i == 3) &#123; iterator.remove(); //迭代器的remove()方法 &#125; System.out.println(iterator.next()); i ++; &#125;&#125; 方法2使用java并发包(java.util.concurrent)中的类来代替ArrayList 和hashMap。比如使用 CopyOnWriterArrayList代替ArrayList，CopyOnWriterArrayList在是使用上跟ArrayList几乎一样，CopyOnWriter是写时复制的容器(COW)，在读写时是线程安全的。该容器在对add和remove等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于CopyOnWriterArrayList在迭代过程并不会发生fail-fast现象。但 CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。对于HashMap，可以使用ConcurrentHashMap，ConcurrentHashMap采用了锁机制，是线程安全的。在迭代方面，ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据 ，iterator完成后再将头指针替换为新的数据 ，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。即迭代不会发生fail-fast，但不保证获取的是最新的数据。参考链接：http://www.jb51.net/article/84468.htmhttp://www.cnblogs.com/ccgjava/p/6347425.html?utm_source=itdadao&amp;utm_medium=referral","categories":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"},{"name":"集合","slug":"集合","permalink":"http://yoursite.com/tags/集合/"},{"name":"fail-fast","slug":"fail-fast","permalink":"http://yoursite.com/tags/fail-fast/"}],"keywords":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}]},{"title":"浅谈ArrayList动态扩容","slug":"浅谈ArrayList动态扩容","date":"2017-10-23T14:54:24.000Z","updated":"2019-05-04T07:47:02.949Z","comments":true,"path":"2017/10/23/浅谈ArrayList动态扩容/","link":"","permalink":"http://yoursite.com/2017/10/23/浅谈ArrayList动态扩容/","excerpt":"","text":"环境eclipsejdk1.8 简介ArrayList实现了List接口，继承了AbstractList，底层是数组实现的，一般我们把它认为是可以自增扩容的数组。它是非线程安全的，一般多用于单线程环境下(与Vector最大的区别就是，Vector是线程安全的，所以ArrayList 性能相对Vector 会好些)，它实现了Serializable接口，因此它支持序列化，能够通过序列化传输(实际上java类库中的大部分类都是实现了这个接口的)，实现了RandomAccess接口，支持快速随机访问(只是个标注接口，并没有实际的方法),这里主要表现为可以通过下标直接访问(底层是数组实现的，所以直接用数组下标来索引)，实现了Cloneable接口，能被克隆。ArrayList：RandomAccess 初始化ArrayList一共提供了三个初始化的方法： 123public ArrayList()public ArrayList(Collection&lt;? extends E&gt; c)public ArrayList(int initialCapacity)； 首先看看源码里无参构造方法的实现：上面的注释表示他会默认提供容量为10的数组，但是实际并不是在这一步实现。可以看看这里的DEFAULTCAPACITY_EMPTY_ELEMENTDATA和elementData：只是一个空数组。所以这一步实际上只是将elementData指向一个空数组而已。再来看看带参数的构造方法：这个方法是直接将一个集合作为ArrayList的元素，很容易看懂，不多做解释，此时elementData即为集合c转为的数组，size即为elementData的长度。这里size是ArrayList的一个int型私有变量，用于记录该list集合中当前元素的数量，注意不是容量。再来看看带初始化容量的构造方法：从源码里可以看出：首先对传进来的初始化参数initialCapacity进行判断，如果该参数大于0，在elementData进行初始化，初始化为一个容量为initialCapacity的数组，如果传进来的参数initialCapacity等于0，则将elementData指向了EMPTY_ELEMENTDATA，从这个名字也可以猜出，是个空数组： add方法的实现说了这么多，还没有说到无参构造函数默认是空数组，为什么注释说是容量为10的数组，也还没说到当容量不足时，是如何实现动态扩容的，下面就通过add方法来说明这些问题。(add方法是list接口中声明的通用方法)。ArrayList的add方法实现如下：size是当前集合拥有的元素个数(未算进准备新增的e元素)，从源码看出，调用了ensureCapacityInternal来保证容量问题，传进去的参数是size+1，来保证新增元素后容量满足要求。接下来进入ensureCapacityInternal方法查看其实现：可以看到代码段： 123if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);&#125; 通过这一步来判断，当前elementData是否为空数组(即初始化容量为0或者调用了无参构造函数后的结果)，如果是，则使用Math.max(DEFAULT_CAPACITY, minCapacity)进行选择一个较大的，其中，DEFAULT_CAPACITY是ArrayList定义的静态常量10：可以看出，这里如果minCapacity小于10的话(如果elementData为空的话，size+1即minCapacity一般为1)，返回的是10，所以如果没有指定大小的话，默认是初始化一个容量为10的数组。然后在调用ensureExplicitCapacity方法：可以看到modCount++，这里可以暂时不管它，这个参数主要是用在集合的Fail-Fast机制(即快速失败机制)的判断中使用的。(以后有空再补充这方面的内容)在这个方法里进行判断，新增元素后的大小minCapacity是否超过当前集合的容量elementData.length，如果超过，则调用grow方法进行扩容。我们进入该方法进行查看:在这里可以很清楚的看到扩容容量的计算:int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),其中oldCapacity是原来的容量大小，oldCapacity &gt;&gt; 1 为位运算的右移操作，右移一位相当于除以2，所以这句代码就等于int newCapacity = oldCapacity + oldCapacity / 2；即容量扩大为原来的1.5倍(注意我这里使用的是jdk1.8，没记错的话1.7也是一样的)，获取newCapacity后再对newCapacity的大小进行判断，如果仍然小于minCapacity，则直接让newCapacity 等于minCapacity，而不再计算1.5倍的扩容。然后还要再进行一步判断，即判断当前新容量是否超过最大的容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0)，如果超过，则调用hugeCapacity方法，传进去的是minCapacity，即新增元素后需要的最小容量：如果minCapacity大于MAX_ARRAY_SIZE，则返回Integer的最大值。否则返回MAX_ARRAY_SIZE。然后回到grow方法，调用Arrays.copyof方法，即复制原数组内容到一个新容量的大数组里。这里Arrays.copyof方法实际是调用System.arraycopy方法。到这里，应该可以很清楚的知道ArrayList底层扩容的原理了。与Vector不同的是，Vector每次扩容容量是翻倍，即为原来的2倍，而ArrayList是1.5倍。看似1.5倍增长的很慢，那经常增加大量元素会不会导致经常扩容，数组重新分配导致效率低下呢？其实不然，每次增长为原来的1.5倍实际增长的量会越来越大的，可以看看网友统计的数据(参考：http://blog.csdn.net/java2000_net/article/details/5215882)： 1千需要分配 11次1万一级需要分配17次10万 需要分配23次100万需要分配28次 当然，如果一开始知道数据量很大的话，可以在初始化时预先指定容量。 get方法很明显是通过数组下标索引来指定返回的数组，这里不多做解释。 验证无参构造函数，add三个元素，按照理解，此时默认容量应该为10：可以看出：elementData容量为10，size为3。 无参构造函数，增加12个元素：测试代码： 123456List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0 ; i &lt; 12; i ++) &#123; list.add(i); &#125; System.out.println(\"ok\"); 通过debug查看结果：看到elementData扩容为15(10+10/2 = 15),而集合元素size为12。 无参构造函数，增加原来的1.5倍扩容量的数据：测试代码： 12345678910List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); List&lt;Integer&gt; newList = new ArrayList&lt;&gt;(); for (int i = 0 ; i &lt; 5; i ++) &#123; 初始5个 list.add(i); &#125; for (int i = 5 ; i &lt; 20; i ++) &#123; newList.add(i); &#125; list.addAll(newList); //一次性增加15个 System.out.println(\"ok\"); 正常情况下，新增5个后，容量为10，再次新增，会变为原来的1.5倍，即15，但是这里新增15个，明显超过，按照上面的理解，应该直接让新容量等于需要的最小容量20，从测试截图可以看到，结果正确。 带集合参数构造函数：测试代码： 123456List&lt;Integer&gt; newList = new ArrayList&lt;&gt;();for (int i = 5 ; i &lt; 20; i ++) &#123; newList.add(i);&#125;List&lt;Integer&gt; list = new ArrayList&lt;&gt;(newList);System.out.println(\"ok\"); 测试结果：可以看到，结果elementData的容量即为集合参数的大小。 总结总之，ArrayList默认容量是10，如果初始化时一开始指定了容量，或者通过集合作为元素，则容量为指定的大小或参数集合的大小。每次扩容为原来的1.5倍，如果新增后超过这个容量，则容量为新增后所需的最小容量。如果增加0.5倍后的新容量超过限制的容量，则用所需的最小容量与限制的容量进行判断，超过则指定为Integer的最大值，否则指定为限制容量大小。然后通过数组的复制将原数据复制到一个更大(新的容量大小)的数组。 附size和modCount的区别可能看了源码有时候还分不清size和modCount的区别，那么这里就用例子来说明。size是ArrayList的变量。modCount是ArrayList的父类AbstractList中的变量，默认值为0。size记录了ArrayList中元素的数量，modCount记录的是关于元素的数目被修改的次数。modCount在ArrayList的普通操作里可能并没有看出多大用处，但是在涉及到fail-fast就主要是依靠它了。直接用下面这段代码进行测试： 12345678910List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.remove(2); list.add(5); list.set(1, 100); list.remove(4); System.out.println(list.size()); 当执行完 list.add(4)时，此时modCount和size都为4：当执行完list.remove(2)时，此时元素数量发生了修改，所以modCount++即5,而size记录集合中元素的个数，移除了一个后，size=size-1即3：当执行完list.add(5)时，此时元素数量再次发生了修改，所以modCount++即5,而size记录集合中元素的个数，增加了一个后，size=size-1即4：当执行完list.set(1, 100)时，元素的数量并没有发生改变，所以modCount和size都不变。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"},{"name":"arraylist","slug":"arraylist","permalink":"http://yoursite.com/tags/arraylist/"},{"name":"扩容","slug":"扩容","permalink":"http://yoursite.com/tags/扩容/"}],"keywords":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}]},{"title":"浅谈Java泛型中的&lt;? extends E&gt;和&lt;? super E&gt;的区别","slug":"浅谈Java泛型中的 extends E和 super E的区别","date":"2017-09-23T13:50:30.000Z","updated":"2019-05-04T07:47:02.950Z","comments":true,"path":"2017/09/23/浅谈Java泛型中的 extends E和 super E的区别/","link":"","permalink":"http://yoursite.com/2017/09/23/浅谈Java泛型中的 extends E和 super E的区别/","excerpt":"","text":"引入再说这个之前，先来看一段代码：假设有这么几个类及其继承关系，后面的例子也用这几个类作为基础示范 123456789101112class People &#123; //人&#125;class Man extends People &#123; //男人&#125;class Woman extends People &#123; //女人&#125;class Boy extends Man &#123; //男孩&#125; 可以看到，man是people的子类，那么： 1List&lt;People&gt; list= new ArrayList&lt;Man&gt;(); 是否可以编译通过？很明显，编译的时候报错了。man是people的子类，ArrayList是List的子类，但并不代表List是List的子类。所以便有了有限通配符 &lt;? extends E&gt;&lt;? extends E&gt; 是 Upper Bound（上限） 的通配符，用来限制元素的类型的上限，比如： 1List&lt;? extends People&gt; list_1 = null; 表示集合中的元素上限是People，即只能是People或People的子类，所以下面的赋值是合法的，编译时候不会报错：但不能是其父类，否则编译时候就报错了：接下来对其读写数据进行了解： 读不管给该list_1如何赋值，可以保证的是里面存放的一定是People或People的子类，编译器可以确定获取的是People类型，所以可以直接从该集合中读取到People类型。即读取是允许的。 写People、Man、Woman都是People类或其子类，但是这里却是编译错误的。原因是? extends People&gt;仅仅告诉编译器该集合元素类型上限是People，这里编译器并不能确定具体的类型，即它可能实际指向了Man，但是你却add一个Woman类型，所以这里编译器不允许这么做。 &lt;? super E&gt;&lt;? super E&gt; 是 Lower Bound（下限） 的通配符 ，用来限制元素的类型下限，比如： 1List&lt;? super Man&gt; list_4 = null; 该表示给出了集合中元素的下限是Man，即只能为Man或者Man的父类，而不能是Man的子类，如下：接下来对其读写数据进行了解： 读允许从该集合获取元素，但是无法保证里面存放的是Man或者是Woman，唯一可以确定的是存放的是Object或其子类，而无法确定具体的类型。这样都没错，但是实际用的时候还是要注意，像这样获取Woman可能导致异常。 写可以确定的是集合中的元素一定是Man或Man的子类，所以添加Man或Boy都是正确的，但是不能添加非Man的子类： 使用场景很多时候都是用它来当作方法中的形参。这里先了解下PECS法则 PECSPECS指“Producer Extends，Consumer Super”。换句话说，如果参数化类型表示一个生产者，就使用&lt;? extends T&gt;；如果它表示一个消费者，就使用&lt;? super T&gt; 例子这里使用网上常见的例子水果来说明，有如下关系：假设此时有个水果供应商Produce， 12345678class Produce&lt;E&gt; &#123; public void produce(List&lt;E&gt; list) &#123; for (E e : list) &#123; //生产... System.out.println(\"批量生产...\"); &#125; &#125;&#125; 它主要销售水果 123Producer&lt;Pear&gt; p = new Produce&lt;&gt;();List&lt;Pear&gt; pears = new ArrayList&lt;Pear&gt;();p.produce(pears); 这样并没有什么问题。但是万一他突然想换成销售苹果了，此时：这样就会发现，编译并不能通过，因为List已经在初始化时确定为Pear了，而不再兼容Appler类型，即使你最开始使用的是Produce，即方法produce的参数list为List，虽然Apple和Pear是Fruit的子类，但是由上面的引入知识知道，List并不是List的父类，即这样也是行不通的，所以这里就需要使用List&lt;? extends E&gt; list了。修改后如下： 12345678class Producer&lt;E&gt; &#123; public void produce(List&lt;? extends E&gt; list) &#123; for (E e : list) &#123; //利用&lt;? extends E&gt;读取的特性 //生产... &#125; System.out.println(\"批量生产完成...\"); &#125;&#125; 此时只要供应商new的时候为Fruit，则生产的货物只要为Fruit或其子类即可，所以Pear和Apple都可通过。如下：接着举一个消费者的例子(可能例子举得不是很好) 1234567//消费者class Consumer&lt;E&gt; &#123; public E consume(List&lt;E&gt; list) &#123; E e = list.get(0); //模拟消费一个(感觉用队列比较合适) return e; &#125;&#125; 每次消费者都从一个list中消费一个。加入有一个红苹果消费者：这里是没什么问题的，但是红苹果也是苹果，如果这样呢：这时候，&lt;? super E&gt;派上用场了。 1234567//消费者class Consumer&lt;E&gt; &#123; public E consume(List&lt;? super E&gt; list) &#123; E e = (E) list.get(0); //模拟消费一个(感觉用队列比较合适) return e; &#125;&#125; 此时再按刚才的操作：编译并不会出问题了。 其实，在java提供的许多类库里就有用到了，比如Collections的静态方法copy：为了保证在list复制过程中类型的安全，限制了原list的上限，保证了目标数组的下限。 参考链接：https://www.cnblogs.com/wangmingshun/p/5389341.html http://blog.csdn.net/asdfsadfasdfsa/article/details/52794573","categories":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"},{"name":"泛型","slug":"泛型","permalink":"http://yoursite.com/tags/泛型/"}],"keywords":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}]},{"title":"哈夫曼树与哈夫曼编码","slug":"哈夫曼树与哈夫曼编码","date":"2017-09-22T14:15:47.000Z","updated":"2019-05-04T07:47:02.947Z","comments":true,"path":"2017/09/22/哈夫曼树与哈夫曼编码/","link":"","permalink":"http://yoursite.com/2017/09/22/哈夫曼树与哈夫曼编码/","excerpt":"","text":"哈夫曼树哈夫曼树又称最优二叉树, 是一种带权路径长度最短的二叉树。在这个二叉树中，只有叶子节点才是有效的数据节点,其他只是作为路径而构造的。 带权路径长度又称WPL，树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度，即树中所有叶节点的带权路径长度之和。WPL= (W1L1+W2L2+W3L3+…+WnLn)， N个权值Wi(i=1,2,…n)构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li(i=1,2,…n)。可以证明哈夫曼树的WPL是最小的。 哈夫曼编码哈夫曼编码是哈夫曼树的一个应用。哈夫曼编码主要是起到压缩的作用。哈夫曼编码应用广泛，如JPEG中就应用了哈夫曼编码。 构建哈夫曼树和获得哈夫曼编码以及WPL的计算下面用一道题来说明构建哈夫曼树和获得哈夫曼编码的过程： 若以{4,5,6,7,8}作为叶子结点的权值构造哈夫曼树，则其带权路径长度是（） 构造哈夫曼树首先，从4，5，6，7，8 （为了方便，将这个数组称为a）中找到最小的两个数4和5，作为叶子结点（一般按照左小右大的方式）：得到新结点权值 9（4+5=9）,从将9加入到剩余的数中，即此时a为6，7，8，9从中再找到最小的2个数6，7，构造树为：得到新结点权值 13（6+7=13）,从将13加入到剩余的数中，即此时a为13，8，9，从剩余的数中找到最小的2个数8和9，构造数为：得到新结点权值17（8+9=17）,从将17加入到剩余的数中，即此时a为13，17.最后这两个节点构成根结点：此时哈夫曼树构造完成了。那么哈夫曼编码怎么算呢？按左小右大就是结点的左边连线为0，右边为1，即： 获取哈夫曼编码：则相应数（可以看到叶子结点就是原先数组a中的数），所以只需遍历叶子结点，对每个结点，从根结点往下，直到该叶子结点的路径对应的数，即为该数的哈夫曼编码。如上图得到的哈夫曼编码分别为：8：004：0105：0116：107：11WPL的计算：叶节点的带权路径长度之和。对本题：权值4和权值5的路径长度为3，7，8，9的长度都为2， 所以WPL为：（4+5）*3+（6+7+8）*2 = 69","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/categories/算法与数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"哈夫曼","slug":"哈夫曼","permalink":"http://yoursite.com/tags/哈夫曼/"},{"name":"哈夫曼编码","slug":"哈夫曼编码","permalink":"http://yoursite.com/tags/哈夫曼编码/"}],"keywords":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/categories/算法与数据结构/"}]},{"title":"mybatis中的#和$的区别","slug":"mybatis中的-和-的区别","date":"2017-09-22T14:10:18.000Z","updated":"2019-05-04T07:47:02.945Z","comments":true,"path":"2017/09/22/mybatis中的-和-的区别/","link":"","permalink":"http://yoursite.com/2017/09/22/mybatis中的-和-的区别/","excerpt":"","text":"简介MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 动态 sql 是 mybatis 的主要特性之一，在mybatis中我们可以把参数传到xml文件，由mybatis对sql及其语法进行解析，mybatis支持使用${}和#{}。可能有些人没有留意到，认为${}和#{}的作用一样，其实他们的功能相似，但还是有区别的。 对比1、使用${}方式传入的参数，mybatis不会对它进行特殊处理，而使用#{}传进来的参数，mybatis默认会将其当成字符串。可能在赋值给如id=#{id}和id=${id}看不出多大区别，但是作为表名或字段参数时可以明显看出，可以看看下面的例子： 假设传入的参数为表名test 1selec * from #&#123;table&#125;; 解析后是： 1select * from \"test\"; 而 1select * from $&#123;table&#125;; 解析后是： 1select * from test; 很明显，前者多了字符串的引号，会失败，后者正常查询会成功； 所以对于传入分组(order)字段或者排序字段(order)，应使用${},避免出现order by “id” 等情况。 2、#和$在预编译处理中是不一样的。#类似jdbc中的PreparedStatement，对于传入的参数，在预处理阶段会使用?代替，比如： 1select * from student where id = ?; 待真正查询的时候即在数据库管理系统中（DBMS）才会代入参数。 而${}则是简单的替换，如下： 1select * from student where id = 2; 总结1、能使用#{}的地方应尽量使用#{} 2、像PreparedStatement ，#{}可以有效防止sql注入，${}则可能导致sql注入成功。 所谓sql注入，就是指把用户输入的数据拼接到sql语句后面作为sql语句的一部分执行，例如： 1select * from user where name=' \"+name+\" ' and password=' \"+password+\" ' 那么只要用户输入用户名admin和密码123456’ or ‘abc’ = ‘abc’,那么拼接出来的语句就为 1select * from user where name=' admin ' and password='123456' or 'abc'= 'abc'; 这样只要user表有数据，就会返回结果，达到sql注入的目的。同样，用户输入用户名a’则 and password=’ “+password+” ‘就会被注释掉，也达到注入sql的目的。 附这里顺带提下防止sql注入的几种方式(可能不止这几种):(1)、jdbc使用 PreparedStatement代替Statement， PreparedStatement 不仅提高了代码的可读性和可维护性.而且也提高了安全性，有效防止sql注入；(2)、在程序代码中使用正则表达式过滤参数。使用正则表达式过滤可能造成注入的符号，如’ –等 (3)、在页面输入参数时也进行字符串检测和提交时进行参数检查，同样可以使用正则表达式，不允许特殊符号出现。","categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/categories/mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"},{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}],"keywords":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/categories/mybatis/"}]},{"title":"死锁的定义、产生原因、必要条件和处理方法","slug":"死锁的定义、产生原因、必要条件和处理方法","date":"2017-09-20T15:31:22.000Z","updated":"2019-05-04T07:47:02.949Z","comments":true,"path":"2017/09/20/死锁的定义、产生原因、必要条件和处理方法/","link":"","permalink":"http://yoursite.com/2017/09/20/死锁的定义、产生原因、必要条件和处理方法/","excerpt":"","text":"死锁的定义在一组进程发生死锁的情况下，这组死锁进程中的每个进程，都在等待另一个死锁进程所占有的资源。死锁的定义如下： 如果一个进程中的每一个进程都在等待仅该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。 死锁的产生原因死锁的起因，通常是源于多个进程对资源的争夺，不仅对不可抢占资源进行争夺或引起死锁，而且对可消耗资源进行争夺也会引起死锁。总结如下： 1、系统资源不足； 2、进程运行推进的顺序不当； 3、资源分配不当； 死锁产生的必要条件1、互斥条件：进程在运行中对资源进行排他性使用，即一个资源仅能被一个进程使用，此时其他进程请求资源时，只能等待其释放。2、请求与保持条件：某进程已经保持了一个资源，但又请求另一个资源，若该资源被其他进程占有，此时请求阻塞，且对已经占有的资源不释放；3、不可抢占条件：进程获得的资源在未使用完时不可被抢占，只能在进程使用完时自己释放； 4、循环等待条件：发生死锁时，必然存在这样一个循环，一个进程p1等待p2占有的资源进程p2等待p3占有的资源…进程pn等待p1占有的资源。 死锁的处理方法1、预防死锁：事先预防策略，容易实现，通过实现设置限制，破坏产生死锁的四个条件之一。(如对资源采用按序分配策略)2、避免死锁：事先预防策略，在资源的动态分配过程中，用某些方法防止系统禁图不安全状态。常见的方法有银行家算法。3、检测死锁：通过检测机构等及时检测出死锁，采取适当措施，把进程从死锁中解脱。4、解除死锁：检测出死锁后，采取措施解决。比如剥夺资源，撤销进程。这四种方法对死锁的防范逐渐减弱，但对应的是资源利用率的提高。 参考自：《计算机操作系统》第四版","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"},{"name":"死锁","slug":"死锁","permalink":"http://yoursite.com/tags/死锁/"}],"keywords":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}]},{"title":"java中非静态内部类可以有常量但不能有staic修饰的属性","slug":"java中非静态内部类可以有常量但不能有staic修饰的属性","date":"2017-09-20T15:24:02.000Z","updated":"2019-05-04T07:47:02.944Z","comments":true,"path":"2017/09/20/java中非静态内部类可以有常量但不能有staic修饰的属性/","link":"","permalink":"http://yoursite.com/2017/09/20/java中非静态内部类可以有常量但不能有staic修饰的属性/","excerpt":"","text":"先看下面的代码： 123456789101112131415package com.howard.test;/** * java中非静态内部类不能有staic修饰的属性，但可以有常量 * 2017年9月12日 * @author hongwu */public class Test2 &#123; public static void main(String[] args) &#123; int a; class innerClass &#123; static int b = 0; //编译不通过 static final int c = 1; //编译通过 &#125; &#125;&#125; java类加载顺序，首先加载类，执行static变量初始化，接下来执行对象的创建，这里的innerClass是非静态内部类，非静态内部类，依赖于一个外部类对象，而静态域/方法是不依赖于对象——仅与类相关，也就是说，这里如果在初始化变量b时，需要依赖于外部类的实例化，外部类还没创建，所以这里的static int b是无法初始化的，而static final int c = 1 不同（static可有可无），他是一个常量，而常量jvm在编译期就确定下来并将它放在常量池的，所以这里可以不会报错。再看下面的代码： 123456class Test2_2 &#123; static class innerClass &#123; static int b = 0; //编译通过 static final int c = 1; //编译通过 &#125;&#125; 这里两个都不会报错，与上面的区别是这里的内部类是静态内部类，静态内部类是不依赖于外部类的实例化的，所以这里的static int b是不会报错的。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"},{"name":"静态","slug":"静态","permalink":"http://yoursite.com/tags/静态/"},{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}],"keywords":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}]},{"title":"最大奇约数","slug":"最大奇约数","date":"2017-08-31T14:05:48.000Z","updated":"2019-05-04T07:47:02.949Z","comments":true,"path":"2017/08/31/最大奇约数/","link":"","permalink":"http://yoursite.com/2017/08/31/最大奇约数/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.howard.algorithm.test; import java.util.Scanner;/** * 小易是一个数论爱好者，并且对于一个数的奇数约数十分感兴趣。一天小易遇到这样一个问题： 定义函数f(x)为x最大的奇数约数，x为正整数。 例如:f(44) = 11. * 现在给出一个N，需要求出 f(1) + f(2) + f(3).......f(N) * 例如： N = 7 * f(1) + f(2) + f(3) + f(4) + f(5) + f(6) + f(7) = 1 + 1 + 3 + 1 + 5 + 3 + 7 = 21 * 小易计算这个问题遇到了困难，需要你来设计一个算法帮助他。 * 2017年8月17日 * @author howard */public class MaxOddSubmultiple &#123; public static void main(String[] args) &#123;// int num = 7; Scanner scanner = new Scanner(System.in); int num = scanner.nextInt(); scanner.close(); int result = 0; for (int i = 1 ; i &lt;= num; i ++ ) &#123; result += getMaxOddSubmultiple(i); &#125; System.out.println(result); &#125; public static int getMaxOddSubmultiple(int num) &#123; int result = 1; if (num % 2 != 0) return num; else &#123; int y = (int) Math.sqrt(num); if (y % 2 == 0) &#123; return y; &#125; for (int i = y - 1 ; i &gt;= 1; i -= 2) &#123; if (num % i == 0) &#123; result = i; break; &#125; &#125; &#125; return result; &#125;&#125; 运行结果：","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/categories/算法与数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"笔试","slug":"笔试","permalink":"http://yoursite.com/tags/笔试/"}],"keywords":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/categories/算法与数据结构/"}]},{"title":"交错01串","slug":"交错01串","date":"2017-08-31T13:26:32.000Z","updated":"2019-05-04T07:47:02.946Z","comments":true,"path":"2017/08/31/交错01串/","link":"","permalink":"http://yoursite.com/2017/08/31/交错01串/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142package com.howard.algorithm.test; import java.util.Scanner;/** * [编程题] 交错01串 * 时间限制：1秒 * 空间限制：32768K * 如果一个01串任意两个相邻位置的字符都是不一样的,我们就叫这个01串为交错01串。例如: \"1\",\"10101\",\"0101010\"都是交错01串。 * 小易现在有一个01串s,小易想找出一个最长的连续子串,并且这个子串是一个交错01串。小易需要你帮帮忙求出最长的这样的子串的长度是多少。 * 输入描述：输入包括字符串s,s的长度length(1 ≤ length ≤ 50),字符串中只包含'0'和'1' * 输出描述:输出一个整数,表示最长的满足要求的子串长度。 * 输入例子：111101111 * 输出例子：3 * 2017年8月15日 * @author howard */public class MaxSubStringWith0Or1 &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String s = in.next(); in.close(); //String s = \"1000001101\"; int max = 0; int tmp = 1; for (int i = 1 ; i &lt; s.length(); i ++ ) &#123; if (s.substring(i, i+1).equals(s.substring(i-1,i))) &#123; if (max &lt; tmp) &#123; max = tmp; &#125; tmp = 1; &#125;else &#123; tmp ++ ; if (i == (s.length() - 1)) &#123; if (max &lt; tmp) &#123; max = tmp; &#125; &#125; &#125; &#125; System.out.println(max); &#125;&#125; 运行结果：","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/categories/算法与数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"笔试","slug":"笔试","permalink":"http://yoursite.com/tags/笔试/"}],"keywords":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/categories/算法与数据结构/"}]},{"title":"数字翻转","slug":"数字翻转","date":"2017-08-31T13:11:05.000Z","updated":"2019-05-04T07:47:02.948Z","comments":true,"path":"2017/08/31/数字翻转/","link":"","permalink":"http://yoursite.com/2017/08/31/数字翻转/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.howard.algorithm; import java.util.ArrayList;import java.util.List;import java.util.Scanner;/** * [编程题] * 时间限制：1秒 * 空间限制：32768K * 对于一个整数X，定义操作rev(X)为将X按数位翻转过来，并且去除掉前导0。例如: * 如果 X = 123，则rev(X) = 321; * 如果 X = 100，则rev(X) = 1. * 现在给出整数x和y,要求rev(rev(x) + rev(y))为多少？ * 输入描述: * 输入为一行，x、y(1 ≤ x、y ≤ 1000)，以空格隔开。 * 输出描述: * 输出rev(rev(x) + rev(y))的值 * 输入例子1:123 100 * 输出例子1:223 * * 2017年8月12日 * @author howard */public class RevNum &#123; public static int rev(int num) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int newNum = 0; while (num &gt; 0) &#123; int x = num%10; num = num/10; list.add(x); &#125; int z = 1; for (int i = list.size() - 1 ; i &gt;= 0 ; i -- ) &#123; newNum += list.get(i) * z; z *= 10; &#125; return newNum; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int x = scanner.nextInt(); int y = scanner.nextInt(); System.out.println(rev(rev(x) + rev(y))); scanner.close(); &#125;&#125; 运行结果：","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/categories/算法与数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"笔试","slug":"笔试","permalink":"http://yoursite.com/tags/笔试/"}],"keywords":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/categories/算法与数据结构/"}]},{"title":"maven项目中手动安装jar包到自己本地仓库","slug":"maven项目中手动安装jar包到自己本地仓库","date":"2016-05-26T05:08:04.000Z","updated":"2019-05-04T07:47:02.945Z","comments":true,"path":"2016/05/26/maven项目中手动安装jar包到自己本地仓库/","link":"","permalink":"http://yoursite.com/2016/05/26/maven项目中手动安装jar包到自己本地仓库/","excerpt":"","text":"问题maven项目pom中引用memcached的依赖包 12345&lt;dependency&gt; &lt;groupId&gt;com.danga&lt;/groupId&gt; &lt;artifactId&gt;memcached&lt;/artifactId&gt; &lt;version&gt;2.6.6&lt;/version&gt;&lt;/dependency&gt; 发现并没有成功下载jar包 弄了好久，查看网上资料结果是: 由于目前java memcached client没有官方的maven repository可供使用，因此使用时需要手动将其安装到本地repository。 安装jar到本地仓库这里以memcached为例。其它jar安装方式类似。 先去官网或者其它网站下载需要的jar包，放在某目录下。这里假设为E:/a/java_memcached-release_2.6.6.jar 打开cmd输入： 1mvn install:install-file -Dfile=e:/a/java_memcached-release_2.6.6.jar -DgroupId=com.danga -DartifactId=memcached -Dversion=2.6.6 -Dpackaging=jar -DgeneratePom=true 显示安装成功，就可以成功在eclipse用上面的pom语句来引入memcached的jar包 -DgroupId=com.danga -DartifactId=memcached -Dversion=2.6.6 -Dpackaging=jar -DgeneratePom=true上面这行表示为安装的jar包设置一个pom坐标之后我们在eclipse的项目里pom引用这个jar包要遵循这个坐标 其他jar包安装方法类似","categories":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"http://yoursite.com/categories/踩过的坑/"}],"tags":[{"name":"jdk","slug":"jdk","permalink":"http://yoursite.com/tags/jdk/"},{"name":"踩过的坑","slug":"踩过的坑","permalink":"http://yoursite.com/tags/踩过的坑/"},{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}],"keywords":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"http://yoursite.com/categories/踩过的坑/"}]},{"title":"centos6.5安装tomcat8步骤","slug":"centos6-5安装tomcat8步骤","date":"2016-05-22T02:25:45.000Z","updated":"2019-05-04T07:47:02.941Z","comments":true,"path":"2016/05/22/centos6-5安装tomcat8步骤/","link":"","permalink":"http://yoursite.com/2016/05/22/centos6-5安装tomcat8步骤/","excerpt":"","text":"安装说明安装环境：CentOS-6.5 安装方式：源码安装 软件：apache-tomcat-8.0.29.tar.gz 下载地址：http://tomcat.apache.org/download-70.cgi 安装路径：/usr/local 安装前提系统必须已经安装配置了JDK6+ 安装tomcat将apache-tomcat-8.0.29.tar.gz文件上传到/usr/local中执行以下操作： 1234[root@admin local]# cd /usr/local[root@admin local]# tar -zxv -f apache-tomcat-8.0.29.tar.gz // 解压压缩包 [root@admin local]# rm -rf apache-tomcat-8.0.29.tar.gz // 删除压缩包 [root@admin local]# mv apache-tomcat-8.0.29 tomcat 启动tomcat执行以下操作： 123456[root@admin ~]# /usr/local/tomcat/bin/startup.sh //启动tomcatUsing CATALINA_BASE: /usr/local/tomcatUsing CATALINA_HOME: /usr/local/tomcatUsing CATALINA_TMPDIR: /usr/local/tomcat/tempUsing JRE_HOME: /usr/java/jdk1.7.0/jreUsing CLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar 出现以上的打印信息说明已经成功启动。 验证安装防火墙需要开放8080端口（如果需要外部浏览器访问的话）： 1vim /etc/sysconfig/iptables 新增以下代码： 12 重启防火墙： 1service iptables restart 浏览器输入如下地址验证：http://192.168.1.107:8080/ 其中192.168.1.107为linux机器的ip。 也可以输入curl http://localhost:8080/查看 看到tomcat界面，恭喜，安装成功！ 停止tomcat1/usr/local/tomcat/bin/shutdown.sh","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"centos","slug":"centos","permalink":"http://yoursite.com/tags/centos/"},{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"},{"name":"tomcat","slug":"tomcat","permalink":"http://yoursite.com/tags/tomcat/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}]},{"title":"linux配置永久ip不生效解决方法","slug":"linux配置永久ip不生效解决方法","date":"2016-05-21T12:43:31.000Z","updated":"2019-05-04T07:47:02.944Z","comments":true,"path":"2016/05/21/linux配置永久ip不生效解决方法/","link":"","permalink":"http://yoursite.com/2016/05/21/linux配置永久ip不生效解决方法/","excerpt":"","text":"linux下使用ifconfig eth0 ip地址可以设置ip地址 ，但并不能永久生效 如果想要永久生效，输入命令setup打开图形界面，设置相应ip和DNS后保存即可但是可能你会发现即使service network start 即重启网络后可能输入ifconfig也看不到eth0网卡的信息，说明并没有生效，这时就应该通过如下方式开启网卡。 输入命令： 1vi /etc/sysconfig/network-scripts/ifcfg-eth0 打开vim文本编辑器 修改如下 将eth0网卡的ONBOOT=no修改为ONBOOT=yes 将BOOTPROTO=no修改为BOOTPROTO=yes 再保存，即可","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"踩过的坑","slug":"踩过的坑","permalink":"http://yoursite.com/tags/踩过的坑/"},{"name":"ip","slug":"ip","permalink":"http://yoursite.com/tags/ip/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}]},{"title":"linux下卸载自带jdk以及安装jdk","slug":"linux下卸载自带jdk以及安装jdk","date":"2016-05-20T15:56:10.000Z","updated":"2019-05-04T07:47:02.944Z","comments":true,"path":"2016/05/20/linux下卸载自带jdk以及安装jdk/","link":"","permalink":"http://yoursite.com/2016/05/20/linux下卸载自带jdk以及安装jdk/","excerpt":"","text":"JDK 1.7 下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html一般都要先卸载linux自带的openjdk版本的jdk 卸载自带jdk卸载步骤：这里写的是centos的卸载方法，其他类型linux系统可能有些许区别第一步：查看Linux自带的JDK是否已安装安装好的CentOS会自带OpenJdk,用命令 Java -version ，会有下面的信息：java version “1.6.0”OpenJDK Runtime Environment (build 1.6.0-b09)OpenJDK 64-Bit Server VM (build 1.6.0-b09, mixed mode)最好还是先卸载掉openjdk,再安装sun公司的jdk. 先查看 rpm -qa | grep java 显示如下信息： 12java-1.4.2-gcj-compat-1.4.2.0-40jpp.115java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5 卸载命令： 12yum -y remove java java-1.4.2-gcj-compat-1.4.2.0-40jpp.115yum -y remove java java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5 如果发现系统还有带了如下安装（ rpm -qa | grep java）： 12 输入如下命令卸载： 1rpm -e --nodeps tzdata-java-2013g-1.el6.noarch 验证是否已经卸载： 12java -versionjavac -version 如果上面两条命令都没有输出jdk相关信息，证明卸载成功 安装JDK这里我以jdk1.7为例，安装目录以usr/local为例，将下载好的安装包解压： 12 如果不在相应的目录下，通过mv移到到需要的目录 修改环境变量： 1vim /etc/profile 添加： 123export JAVA_HOME=/usr/local/jdk1.7.0_25 export CLASSPATH=/usr/local/jdk1.7.0_25/lib export PATH=$JAVA_HOME/bin:$PATH 如果你不想重启系统，可以用命令source /etc/profile使配置文件立即生效。否则只能重启系统才能使配置参数生效： 1source /etc/profile 接着验证环境变量是否生效： 12345678[root@localhost ~]# echo $JAVA_HOME /usr/java/jdk1.7.0_25 [root@localhost ~]# echo $PATH /usr/java/jdk1.7.0_25/bin:/usr/kerberos/sbin:/usr/kerberos/bin :/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/X11R6/bin:/root/bin [root@localhost ~]# echo echo $CLASSPATH /usr/java/jdk1.7.0_25/lib [root@localhost ~]# 最后， 验证安装成功与否，以及环境变量是否生效： 12java -versionjavac -version 输出相应的版本信息，说明安装成功。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"},{"name":"jdk","slug":"jdk","permalink":"http://yoursite.com/tags/jdk/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}]},{"title":"主机无法访问虚拟机Linux的apache","slug":"主机无法访问虚拟机Linux的apache","date":"2016-05-17T16:47:32.000Z","updated":"2019-05-04T07:47:02.946Z","comments":true,"path":"2016/05/18/主机无法访问虚拟机Linux的apache/","link":"","permalink":"http://yoursite.com/2016/05/18/主机无法访问虚拟机Linux的apache/","excerpt":"","text":"在虚拟机linux里安装了httpd，即appache，启动后，按正常情况在主机是可以用浏览器通过访问虚拟机linux的ip来访问的。如果出现无法访问的情况，解决办法可以参考如下：这里我的虚拟机联网方式为物理连接，且ip与主机不同，但在同一网段。1、先确定虚拟机可不可以访问外网，可通过ping www.baidu.com 测试，如果不行，先百度或者参考其他资料或setup自行配置好ip相关信息（当然，前提是你主机联网了）2、主机与虚拟机通过各自ip互ping ，如果主机可以ping虚拟机，而虚拟机却不可以ping主机，考虑下是不是主机电脑防火墙没有关，很多情况是这个原因，关闭防火墙可以解决。3、如果以上都没问题，还是没能解决，则可能是iptable的限制。通过如下命令把tcp的80端口配置为允许任何ip访问就可以了命令: 1iptables -I INPUT -p TCP --dport 80 -j ACCEPT 注意linux的命令是区分大小写的 但是，上面第三步的方法只是临时生效的，只要你重启了虚拟机或者说重启了linux，就必须重新设置才可以访问，解决办法如下：在命令行下输入： 1vi /etc/selinux/config 会打开vi编辑器修改文件：将SELINUX=enforcing这一行注释掉，并且加上一行，如下： 12#SELINUX=enforcingSELINUX=disabled 再保存，后继续输入命令： 12[root@Fedora6 ~]# chkconfig --level 3 iptables off[root@Fedora6 ~]# chkconfig --level 5 iptables off 之后重启linux，生效，就可以了 这时主机就可以访问虚拟机开启的apache了（这里只是用apache示例，应该说可以同主机浏览器访问虚拟机ip了）","categories":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"http://yoursite.com/categories/踩过的坑/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://yoursite.com/tags/虚拟机/"},{"name":"apache","slug":"apache","permalink":"http://yoursite.com/tags/apache/"}],"keywords":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"http://yoursite.com/categories/踩过的坑/"}]},{"title":"构建好maven项目后运行时出现异常时解决方法参考","slug":"在构建好maven项目后运行时出现异常时解决方法参考","date":"2016-05-13T16:59:29.000Z","updated":"2019-05-04T07:47:02.948Z","comments":true,"path":"2016/05/14/在构建好maven项目后运行时出现异常时解决方法参考/","link":"","permalink":"http://yoursite.com/2016/05/14/在构建好maven项目后运行时出现异常时解决方法参考/","excerpt":"","text":"在构建好maven项目后运行时出现-Dmaven.multiModuleProjectDirectory system property is not set. Check $M2_HOME environment variable and mvn script match. 解决方法参考：eclipse点击window-&gt;perferences-&gt;java-&gt;install jres 选择你使用的jdk，点击右边的edit，出现如下界面：在箭头处输入如下：-Dmaven.multiModuleProjectDirectory=$M2_HOME点击Finish就好了。","categories":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"http://yoursite.com/categories/踩过的坑/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"},{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"},{"name":"异常","slug":"异常","permalink":"http://yoursite.com/tags/异常/"}],"keywords":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"http://yoursite.com/categories/踩过的坑/"}]},{"title":"加上事务aop后项目启动报错解决方法参考","slug":"加上事务aop后项目启动报错解决方法参考","date":"2016-05-04T02:32:02.000Z","updated":"2019-05-04T07:47:02.947Z","comments":true,"path":"2016/05/04/加上事务aop后项目启动报错解决方法参考/","link":"","permalink":"http://yoursite.com/2016/05/04/加上事务aop后项目启动报错解决方法参考/","excerpt":"","text":"很多时候在进行ssm或者ssh整合时会遇到各种搞不清的报错 下面就是我在整合过程遇到的错误，费了好一番功夫才知道错在哪 希望对大家有帮助 在整合中的spring配置文件里 各项我都测试没问题，这时我就加上了aop事务管理 123456789101112131415161718192021222324&lt;!-- 事务管理 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; &lt;!-- 配置事务通知 --&gt;&lt;tx:advice id=\"advice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!-- 默认只处理运行时异常，可加rollback-for=\"Exception/Throwable\"等处理所有异常或包括错误 --&gt; &lt;tx:method name=\"insert*\" propagation=\"REQUIRED\" rollback-for=\"Exception\" /&gt; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\" rollback-for=\"Exception\" /&gt; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\" rollback-for=\"Exception\" /&gt; &lt;tx:method name=\"*\" propagation=\"SUPPORTS\" /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置切面织入的范围,后边要把事务边界定在service层 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=\"advice\" pointcut=\"execution(* com.hw.service.Imp.*.*(..))\" /&gt;&lt;/aop:config&gt; 但是当下面这段代码加上去的时候就连启动都报了错 12345&lt;!-- 配置切面织入的范围,后边要把事务边界定在service层 --&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref=\"advice\" pointcut=\"execution(* com.hw.service.Imp.*.*(..))\" /&gt;&lt;/aop:config&gt; 报错如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394五月 04, 2016 10:21:48 上午 org.apache.catalina.core.StandardContext listenerStart严重: Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListenerorg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'userServiceImp' defined in file [E:\\javaee\\.metadata\\.plugins\\org.eclipse.wst.server.core\\tmp4\\wtpwebapps\\scm1.2\\WEB-INF\\classes\\com\\hw\\service\\Imp\\UserServiceImp.class]: BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0': Initialization of bean failed; nested exception is java.lang.NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld$ReflectionWorldException at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:452) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:293) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:290) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:192) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:585) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:895) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:425) at org.springframework.web.context.ContextLoader.createWebApplicationContext(ContextLoader.java:282) at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:204) at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:47) at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4729) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5167) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1408) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1398) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745)Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0': Initialization of bean failed; nested exception is java.lang.NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld$ReflectionWorldException at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:527) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:293) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:290) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:196) at org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans(BeanFactoryAdvisorRetrievalHelper.java:86) at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findCandidateAdvisors(AbstractAdvisorAutoProxyCreator.java:100) at org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator.shouldSkip(AspectJAwareAdvisorAutoProxyCreator.java:107) at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessBeforeInstantiation(AbstractAutoProxyCreator.java:278) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:848) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:820) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:446) ... 19 moreCaused by: java.lang.NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld$ReflectionWorldException at java.lang.Class.getDeclaredConstructors0(Native Method) at java.lang.Class.privateGetDeclaredConstructors(Class.java:2663) at java.lang.Class.getDeclaredConstructors(Class.java:2012) at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors(AutowiredAnnotationBeanPostProcessor.java:230) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineConstructorsFromBeanPostProcessors(AbstractAutowireCapableBeanFactory.java:930) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:903) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:485) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:270) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:125) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1325) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1086) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:517) ... 31 moreCaused by: java.lang.ClassNotFoundException: org.aspectj.weaver.reflect.ReflectionWorld$ReflectionWorldException at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1313) at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1164) ... 44 more五月 04, 2016 10:21:48 上午 org.apache.catalina.core.StandardContext startInternal严重: One or more listeners failed to start. Full details will be found in the appropriate container log file五月 04, 2016 10:21:48 上午 org.apache.catalina.core.StandardContext startInternal严重: Context [/scm1.2] startup failed due to previous errors五月 04, 2016 10:21:48 上午 org.apache.catalina.core.ApplicationContext log信息: Closing Spring root WebApplicationContext五月 04, 2016 10:21:48 上午 org.apache.catalina.loader.WebappClassLoaderBase clearReferencesJdbc警告: The web application [scm1.2] registered the JDBC driver [com.mysql.jdbc.Driver] but failed to unregister it when the web application was stopped. To prevent a memory leak, the JDBC Driver has been forcibly unregistered.五月 04, 2016 10:21:48 上午 org.apache.catalina.loader.WebappClassLoaderBase clearReferencesThreads警告: The web application [scm1.2] appears to have started a thread named [Timer-0] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread: java.lang.Object.wait(Native Method) java.util.TimerThread.mainLoop(Timer.java:552) java.util.TimerThread.run(Timer.java:505)五月 04, 2016 10:21:48 上午 org.apache.catalina.loader.WebappClassLoaderBase clearReferencesThreads警告: The web application [scm1.2] appears to have started a thread named [com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread-#0] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread: java.lang.Object.wait(Native Method) com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread.run(ThreadPoolAsynchronousRunner.java:534)五月 04, 2016 10:21:48 上午 org.apache.catalina.loader.WebappClassLoaderBase clearReferencesThreads警告: The web application [scm1.2] appears to have started a thread named [com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread-#1] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread: java.lang.Object.wait(Native Method) com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread.run(ThreadPoolAsynchronousRunner.java:534)五月 04, 2016 10:21:48 上午 org.apache.catalina.loader.WebappClassLoaderBase clearReferencesThreads警告: The web application [scm1.2] appears to have started a thread named [com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread-#2] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread: java.lang.Object.wait(Native Method) com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread.run(ThreadPoolAsynchronousRunner.java:534)五月 04, 2016 10:21:48 上午 org.apache.catalina.loader.WebappClassLoaderBase clearReferencesThreads警告: The web application [scm1.2] appears to have started a thread named [Abandoned connection cleanup thread] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread: java.lang.Object.wait(Native Method) java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:142) java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:158) com.mysql.jdbc.NonRegisteringDriver$1.run(NonRegisteringDriver.java:93)五月 04, 2016 10:21:48 上午 org.apache.coyote.AbstractProtocol start信息: Starting ProtocolHandler [\"http-nio-8080\"]五月 04, 2016 10:21:48 上午 org.apache.coyote.AbstractProtocol start信息: Starting ProtocolHandler [\"ajp-nio-8009\"]五月 04, 2016 10:21:48 上午 org.apache.catalina.startup.Catalina start信息: Server startup in 17888 ms 经过各种查资料： 发现是少了个jar包： com.springsource.org.aspectj.weaver-1.6.8.RELEASE有些版本也叫：aspectj.weaver.jar","categories":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"http://yoursite.com/categories/踩过的坑/"}],"tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"},{"name":"异常","slug":"异常","permalink":"http://yoursite.com/tags/异常/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"}],"keywords":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"http://yoursite.com/categories/踩过的坑/"}]}]}