<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[继承和组合的区别]]></title>
    <url>%2F2019%2F05%2F04%2F%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[什么是继承继承是面向对象三大基本特征之一(继承，封装，多态)，继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。在java中通过关键字extends实现继承，java中所有类默认都是java.lang.Object的子类。继承强调的是is-a关系。直接通过例子来了解继承： 12345678/** * 动物 */public class Animal &#123; public void breathing() &#123; System.out.println("呼气...吸气..."); &#125;&#125; 123456789101112131415/** * 飞行动物 * 继承 */public class FlyingAnimals extends Animal&#123; public void filying() &#123; System.out.println("飞行..."); &#125; public static void main(String[] args) &#123; FlyingAnimals flyingAnimals = new FlyingAnimals(); flyingAnimals.breathing(); flyingAnimals.filying(); &#125;&#125; 运行结果： 呼气…吸气…飞行… 继承是代码复用的一种方式。在继承中，父类的方法内部实现细节对子类可见，是‘白盒式’的代码复用。 什么是组合组合是通过对现有对象进行拼装即组合产生新的具有更复杂的功能。如： 12345678/** * 动物 */public class Animal &#123; public void breathing() &#123; System.out.println("呼气...吸气..."); &#125;&#125; 123456789101112131415161718192021222324252627/** * 爬行动物 * 组合 */public class Reptilia &#123; private Animal animal; public Reptilia(Animal animal) &#123; this.animal = animal; &#125; public void crawling() &#123; System.out.println("爬行..."); &#125; public void breathing() &#123; animal.breathing(); &#125; public static void main(String[] args) &#123; Animal animal = new Animal(); Reptilia reptilia = new Reptilia(animal); reptilia.breathing();; reptilia.crawling(); &#125;&#125; 运行结果： 呼气…吸气…爬行… 组合体现的是整体和部分，强调的是has-a的关系。所以组合更多的用于下面这样的场景： 12345678910111213141516/** * 轮胎 */class Tire &#123; public void run() &#123; System.out.println("轮胎转动..."); &#125;&#125;/** * 车灯 */class Light &#123; public void light() &#123; System.out.println("灯亮..."); &#125;&#125; 12345678910111213141516171819202122232425/** * 交通工具 * 组合 */public class Vehicle &#123; private Tire tire; private Light light; public Vehicle(Tire tire,Light light) &#123; this.tire = tire; this.light = light; &#125; public void operation() &#123; light.light(); tire.run(); &#125; public static void main(String[] args) &#123; Tire tire = new Tire(); Light light = new Light(); Vehicle vehicle = new Vehicle(tire,light); vehicle.operation(); &#125;&#125; 运行结果： 灯亮…轮胎转动… 继承与组合的区别与联系继承与组合都是面向对象中代码复用的方式。父类的内部细节对子类可见，其代码属于白盒式的复用，而组合中，对象之间的内部细节不可见，其代码属于黑盒式复用。继承在编码过程中就要指定具体的父类，其关系在编译期就确定，而组合的关系一般在运行时确定。继承强调的是is-a的关系，而组合强调的是has-a的关系。 继承与组合的优缺点继承的优缺点优点： 支持扩展，通过继承父类实现，但会使系统结构较复杂 易于修改被复用的代码缺点： 代码白盒复用，父类的实现细节暴露给子类，破坏了封装性 当父类的实现代码修改时，可能使得子类也不得不修改，增加维护难度。 子类缺乏独立性，依赖于父类，耦合度较高 不支持动态拓展，在编译期就决定了父类组合的优缺点优点： 代码黑盒复用，被包括的对象内部实现细节对外不可见，封装性好。 整体类与局部类之间松耦合，相互独立。 支持扩展 每个类只专注于一项任务 支持动态扩展，可在运行时根据具体对象选择不同类型的组合对象(扩展性比继承好)缺点： 创建整体类对象时，需要创建所有局部类对象。导致系统对象很多。 什么情况下使用继承，什么情况下使用组合从前面的分析看，组合的优点明显多于继承，再加上java中仅支持单继承，所以：除非两个类之间是is-a的关系，否则尽量使用组合。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>继承</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的代理模式（Proxy）]]></title>
    <url>%2F2019%2F05%2F04%2Fjava%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88proxy%EF%BC%89%2F</url>
    <content type="text"><![CDATA[代理模式介绍什么是代理模式代理模式：为其他对象提供一种代理以控制对这个对象的访问；代理模式的好处：在目标对象的基础上，去添加额外的功能操作，而不修改原先的业务方法。让业务方法去专注于自己的业务逻辑。代理模式让我们可以去扩展目标对象的功能。通俗点，就是有个代理人去帮我们处理琐碎的事情。 代理模式的分类代理模式主要分为:1、静态代理：由工具或者开发者手动生成代理源代码，并对其进行编译成.class，这种方式，在运行前.class文件就已经存在了。不够灵活。2、动态代理：在程序运行时，通过运用反射机制动态生成.class。（1） jdk动态代理：代理所有“实现的有接口”的目标类（2） cglib动态代理：代理任意一个目标类，但对final类和方法无法代理 静态代理模式的uml图典型的静态的代理模式uml图如下：主要的角色：Subject：抽象主题角色，负责定义RealSubject(目标对象)和Proxy(代理对象)角色应该实现的接口RealSubject：具体主题角色，即被代理对象，用来真正完成业务服务功能Proxy：代理主题角色，委托类，负责将自身的Request请求，调用realsubject 对应的request功能来实现业务功能，自己不真正做业务。 静态代理先来定义两个类：UserService和UserServiceImpl 12345678/** * 接口 * @author hongwu * */public interface UserService &#123; void save();&#125; 1234567891011121314/** * 对象 * 代理目标对象 * @author hongwu * */public class UserServiceImpl implements UserService&#123; @Override public void save() &#123; System.out.println("保存操作..."); &#125;&#125; 下面的几个例子都将使用这两个类来举例。先来看看静态代理的例子： 123456789101112131415161718192021222324252627package com.howard.demo.proxy.staticproxy;import com.howard.demo.proxy.UserService;/** * 静态代理 * @author hongwu * */public class UserServiceProxy implements UserService&#123; private UserService target; public UserServiceProxy(UserService target) &#123; super(); this.target = target; &#125; @Override public void save() &#123; System.out.println("操作前的预处理..."); target.save(); System.out.println("操作后的处理..."); &#125;&#125; 123456789101112/** * 静态代理测试类 * @author hongwu * */public class Test &#123; public static void main(String[] args) &#123; UserService target = new UserServiceImpl(); UserServiceProxy proxy = new UserServiceProxy(target); proxy.save(); &#125;&#125; 运行结果： 操作前的预处理…保存操作…操作后的处理… 静态代理可以在不修改目标对象代码的前提下，对目标对象功能进拓展，但是，由于静态代理对每一个被代理对象都要编写一个代理类，一旦有很多需要被代理的对象时，就要写很多代理类，所以就有了动态代理的方式。 动态代理动态代理是指在运行时，动态生成代理类。即，代理类的字节码将在运行时生成并载入当前的ClassLoader。动态代理的实现方式主要有两种，一种是使用jdk自带的对于动态代理的支持，一种是使用cglib的方式。 jdk对于动态代理的支持jdk的动态代理是基于接口的。主要使用Proxy的静态方法和创建一个类实现 InvocationHandler接口，通过重写invoke)()方法来完成。 12345public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) public Object invoke(Object proxy, Method method, Object[] args) throws Throwable 主要做了以下几个工作：1、获取RealSubject上的所有接口；2、确定要生成的代理类的类名，默认为com.sun.proxy.$ProxyXXX;3、根据需要实现的接口信息，在代码中动态创建该Proxy类的字节码；4、将对应的字节码转换为对应的class对象；5、创建InvocationHandler实例实现handler，处理Proxy的所有方法调用。6、Proxy的class对象以创建的handler对象为参数，实例化一个proxy对象。例子： 1234567891011121314151617181920212223242526272829/** * jdk 动态代理 * @author hongwu * */public class JDKProxy implements InvocationHandler&#123; //被代理类 private Object target; //Object 可以接受不同的代理类 public Object getInstance(Object target) &#123; this.target = target; //Object java.lang.reflect.Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) //注意这里创建代理对象时传入的第二个参数是代理对象的接口对象 jdk的proxy代理只能代理接口对象，所以被代理类都必须有实现接口 return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object obj = null; System.out.println("操作前的预处理..."); obj = method.invoke(target, args); System.out.println("操作后的处理..."); return obj; &#125;&#125; 测试： 1234567891011public class Test &#123; public static void main(String[] args) &#123; //打开这个配置 可以把生成$Proxy0的class文件保存下来 //System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true"); //只能代理接口对象 UserService service = (UserService) new JDKProxy().getInstance(new UserServiceImpl()); System.out.println(service.getClass().getName()); //com.sun.proxy.$Proxy0 service.save(); &#125;&#125; 运行后可以看到： com.sun.proxy.$Proxy0操作前的预处理…保存操作…操作后的处理… 可以看到，返回的UserService是一个代理对象：$Proxy0为了可以看看这个代理对象究竟是怎样的一个类，可以打开注释掉的那个配置，是生成的class文件保存到本地： 1System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true"); 运行后会发现生成的$Proxy0的class文件，使用反编译工具进行查看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.sun.proxy;import com.howard.demo.proxy.UserService;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements UserService&#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; public $Proxy0(InvocationHandler paramInvocationHandler) throws &#123; super(paramInvocationHandler); &#125; public final boolean equals(Object paramObject) throws &#123; try &#123; return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void save() throws &#123; try &#123; this.h.invoke(this, m3, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)this.h.invoke(this, m2, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)this.h.invoke(this, m0, null)).intValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] &#123; Class.forName("java.lang.Object") &#125;); m3 = Class.forName("com.howard.demo.proxy.UserService").getMethod("save", new Class[0]); m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]); m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125;&#125; 可以看到该类继承自 java.lang.reflect.Proxy，里面所有的方法都是final的，并且方法内部功能的实现都统一调用了InvocationHandler的invoke()方法。所以动态代理与反射是有很大关系的。但是jdk实现的动态代理有一个缺点，那就是被代理的对象都必须有实现的接口，所以生成的代理类也只能代理该接口定义的方法。而cglib动态代理就不会有这个问题。 cglib实现动态代理cglib(Code Generation Library)实现动态代理是基于ASM框架实现的，需要cglib和asm两个jar包。maven下导入下面的依赖默认asm也会加入： 123456&lt;!-- cglib --&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; cglib代理，,也叫作子类代理，它是在内存中构建一个子类对象并覆盖其中方法实现增强，从而实现对目标对象功能的扩展.，但因为采用的是继承，所以不能对final修饰的类进行代理。CGLIB创建某个类A的动态代理类的模式是：1、查找A上的所有非final的public类型的方法定义2、将这些方法的定义转换成字节码3、将组成的字节码转换成相应的代理的class对象4、实现MethodInterceptor接口，用来处理对代理类上所有方法的请求（这个接口和Jdk动态代理InvocationHandler的功能和角色是一样的）cglib动态代理的核心类是：Enhancer，它负责代理对象的生命周期，提供很多方法来帮助我们完成代理实例的创建。其中最主要的两个方法是： 123public void setSuperclass(Class superclass) ；//设置父类，即传入代理对象//设置了回调。也就是将来对我们代理中方法的访问会转发到该回调中，所有自定义的回调类必须继承MethodInterceptor接口并实现其intercept方法，这一点和jdk的InvocationHandler类似。public void setCallback(final Callback callback)； MethodInterceptor接口的intercept方法： 1public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable 其中，proxy指被代理的对象，method指调用的当前方法，args指方法的参数集合，methodProxy被调用方法的代理，它可以和method完成同样的事情，但是它使用FastClass机制非反射执行方法，效率比较高。下面看看具体使用的例子： 12345678910111213141516171819202122232425262728/** * cglib动态代理 * @author hongwu * */public class CglibProxy implements MethodInterceptor&#123; private Object target; public Object getInstance(Object target) &#123; this.target = target; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(target.getClass()); enhancer.setCallback(this); Object proxy = enhancer.create(); return proxy; &#125; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; Object obj = null; System.out.println("操作前的预处理..."); obj = method.invoke(target, args); System.out.println("操作后的处理..."); return obj; &#125;&#125; 测试： 123456789public class Test &#123; public static void main(String[] args) &#123; //可以代理对象 UserServiceImpl service = (UserServiceImpl) new CglibProxy().getInstance(new UserServiceImpl()); //获取到的是代理对象 com.howard.test.proxy.UserServiceImpl$$EnhancerByCGLIB$$6aa6fa4f System.out.println(service.getClass().getName()); service.save(); &#125;&#125; 运行结果： com.howard.demo.proxy.UserServiceImpl$$EnhancerByCGLIB$$3bd67ffa操作前的预处理…保存操作…操作后的处理… sping aop的代理默认是使用jdk的代理方式，如果需要使用cglib，需加上配置： 1&lt;aop:aspectj-autoproxy proxy-target-class="true"&gt; 该配置默认是false]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>代理</tag>
        <tag>动态代理</tag>
        <tag>cglib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F10%2F26%2Fmy-test%2F</url>
    <content type="text"><![CDATA[2019-05-19]]></content>
  </entry>
  <entry>
    <title><![CDATA[优雅的点]]></title>
    <url>%2F2018%2F08%2F31%2F%E4%BC%98%E9%9B%85%E7%9A%84%E7%82%B9%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.howard.algorithm; import java.util.Scanner;/** * 优雅的点 * 时间限制：1秒 * 空间限制：32768K * 小易有一个圆心在坐标原点的圆，小易知道圆的半径的平方。小易认为在圆上的点而且横纵坐标都是整数的点是优雅的，小易现在想寻找一个算法计算出优雅的点的个数，请你来帮帮他。 * 例如：半径的平方如果为25 * 优雅的点就有：(+/-3, +/-4), (+/-4, +/-3), (0, +/-5) (+/-5, 0)，一共12个点。 * 输入描述:输入为一个整数，即为圆半径的平方,范围在32位int范围内。 * 输出描述:输出为一个整数，即为优雅的点的个数 * 输入例子1:25 * 输出例子1:12 * 2017年8月12日 * @author howard */public class BeautifulPoint &#123; public static void main(String[] args) &#123;// System.out.println(findBeautifulPoint(16)); Scanner str = new Scanner(System.in); int num = str.nextInt(); int count = 0; //数（+-x,+-y）等于4个点 for (int i = 0 ; i*i &lt;= num; i ++ ) &#123; //只取比i大的 找到一对数（x,y）则为4*2 for (int j = i ; j * i &lt;= num; j ++ ) &#123; if ((i * i) + (j * j) &gt; num) &#123; break; &#125; if ((i * i) + (j * j) == num) &#123; //+-0 一样 if (i == 0 || j == 0) &#123; count += 4; &#125;else if( i == j)&#123; count += 4; &#125;else &#123; count += 8; &#125; break; &#125; &#125; &#125; System.out.println(count); str.close(); &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类与接口的区别]]></title>
    <url>%2F2018%2F07%2F31%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[什么是抽象类在java中，使用abstract修饰的类就是一个抽象类。如下就是一个抽象类： 1234567891011121314151617181920212223242526/** * 抽象类 */public abstract class A &#123; /** * 抽象类中可以有成员变量，可以有常量 */ private int a; public int b; int c; String str; public static final String STR = "abstract"; //抽象类中可以有构造方法 public A() &#123; &#125; public void funA() &#123; System.out.println("抽象类中可以有普通方法"); &#125; //抽象方法 abstract void funB();&#125; 抽象类可以有成员变量，可以有常量，可以有构造方法，可以有普通方法(包括静态方法)，只要是普通的类中可以有的，抽象方法都可以有。但还是需要注意几点： 抽象类不可以被实例化，即使抽象类有构造方法，但在抽象类中可以有构造方法，只是不能直接创建抽象类的实例对象。在实例化子类的时候，就会初始化父类，不管父类是不是抽象类都会调用父类的构造方法，此时如果是抽象类就会调用抽象类的构造方法； 方法被abstract修饰后，该方法即为抽象方法，此时该方法无方法体，即不能加{}进行实现，且该方法不能再加private、final进行修饰； 抽象类中可以没有抽象方法，但类中只要存在一个抽象方法，该类即为抽象类，不能被实例化； 继承抽象类的子类可以是普通类，如果为普通类，则必须重写抽象类中所有的抽象方法，只要有一个没重写(仍为抽象方法)，则该子类仍为抽象方法。 抽象类不能被final修饰。因为final修饰的类无法被继承 抽象类不能被static修饰，但内部抽象类可以 12345678910111213141516171819202122public abstract class F &#123; abstract static class G &#123; abstract void funGA(); &#125; abstract void funA(); &#125;//继承内部抽象类class H extends F.G &#123; @Override void funGA() &#123; System.out.println("实现F.G抽象类中的方法"); &#125; public static void main(String[] args) &#123; F.G g = new H(); g.funGA(); &#125;&#125; 运行结果： 实现F.G抽象类中的方法 什么是接口在java中，接口使用interface修饰，接口是一种规范，是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。如下就是一个接口： 12345678910111213141516/** * 接口 */public interface B &#123; //接口里可以有常量。默认都是加了public final static //由于是常量，所以必须初始化 //通过接口名.常量访问 如B.a int a = 2; public final static String str = "interface"; //接口中的方法默认都是public abstract修饰 void funA(); public abstract void funB();&#125; 接口可以说是一中特殊的抽象类，接口里的方法都是抽象方法(默认使用了public abstract修饰)。 子类实现接口必须实现接口中的所有方法； 接口中不能有成员变量，只能有常量，即默认都是public final static修饰； 接口不能被实例化； 接口不能有构造方法； 接口可以继承接口，使用extends并且可以继承多个接口： 1234567interface C extends B &#123; int aa = 3;&#125;interface D extends B,C &#123; int dd = 4;&#125; jdk1.8中，接口允许有静态方法（用static修饰），也允许接口有默认实现（用default修饰）。子类实现接口时可以不重写 default修饰的方法。也可以重写覆盖。 1234567891011121314151617181920212223242526272829303132333435363738class E implements D &#123; @Override public void funA() &#123; System.out.println("实现接口A"); &#125; @Override public void funB() &#123; System.out.println("实现接口B"); &#125; /*@Override public void funD() &#123; System.out.println("覆盖默认实现"); &#125;*/ public static void main(String[] args) &#123; E e = new E(); System.out.println("访问接口B中的常量..."); //访问接口B中的常量 System.out.println(B.a); System.out.println(E.a); System.out.println(C.a); //接口中的静态方法 System.out.println("访问接口中的静态方法..."); B.funC(); System.out.println("访问类E中重写接口的方法..."); e.funA(); e.funB(); System.out.println("访问接口中的默认方法..."); e.funD(); &#125;&#125; 运行结果： 访问接口B中的常量…222访问接口中的静态方法…jdk1.8新增的接口中的静态方法访问类E中重写接口的方法…实现接口A实现接口B访问接口中的默认方法…jdk1.8新增的接口中的默认方法实现 抽象类和接口的区别 抽象类和接口都不能实例化 抽象类和接口中的抽象方法都只能有方法声明，不能有方法体（jdk1.8后接口中的默认方法可以有方法体） 抽象类和接口的概念有所不同，抽象类是对根源的抽象，接口是对动作的抽象。通俗点讲就是，抽象类常用于表示这个对象是什么，而接口表示的是这个对象能做什么。 继承抽象类的子类可以不必实现全部抽象方法，此时该子类仍为抽象类；而实现接口的类则必须实现全部的方法(jdk1.8后新特性的默认方法除外) 类只能单继承，接口可以继承接口，并且可以多继承 接口是设计的结果 ，抽象类是重构的结果 抽象类可以有构造方法，接口不能有构造方法 抽象类中的变量没有要求，而接口中的变量必须是public static final即常量抽象类和接口的使用场景 在既需要统一的接口，又需要实例变量来协调或标记状态等情况下，可以使用抽象类； 不想要每个实现类都重写所有的抽象方法的情况下可以使用抽象类； 类与类之间关系比较紧密且需要共享代码或方法，考虑使用抽象类； 仅强调动作，而不在乎其如何实现，考虑使用接口； 需要实现特定的多项功能，且功能之间无比较紧密的联系，考虑使用接口； 参考链接：抽象类和接口的使用场景介绍&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接口和抽象类有什么区别]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>java</tag>
        <tag>抽象类</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的fail-fast(快速失败)机制]]></title>
    <url>%2F2017%2F10%2F30%2Fjava%E4%B8%AD%E7%9A%84fail-fast(%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5)%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[引入在前面介绍浅谈ArrayList动态扩容时对于modCount的操作没有详细说明，该变量的操作在add，remove等操作中都会发生改变。那么该变量到底有什么作用呢？ 简介fail-fast 机制，即快速失败机制，是java集合(Collection)中的一种错误检测机制。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast，即抛出ConcurrentModificationException异常。fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug。 fail-fast的出现场景在我们常见的java集合中就可能出现fail-fast机制,比如ArrayList，HashMap。在多线程和单线程环境下都有可能出现快速失败。 1. 单线程环境下的fail-fastArrayList发生fail-fast例子： 123456789101112131415public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0 ; i &lt; 10 ; i++ ) &#123; list.add(i + ""); &#125; Iterator&lt;String&gt; iterator = list.iterator(); int i = 0 ; while(iterator.hasNext()) &#123; if (i == 3) &#123; list.remove(3); &#125; System.out.println(iterator.next()); i ++; &#125;&#125; 该段代码定义了一个Arraylist集合，并使用迭代器遍历，在遍历过程中，刻意在某一步迭代中remove一个元素，这个时候，就会发生fail-fast。HashMap发生fail-fast： 12345678910111213141516public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); for (int i = 0 ; i &lt; 10 ; i ++ ) &#123; map.put(i+"", i+""); &#125; Iterator&lt;Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); int i = 0; while (it.hasNext()) &#123; if (i == 3) &#123; map.remove(3+""); &#125; Entry&lt;String, String&gt; entry = it.next(); System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue()); i++; &#125;&#125; 该段代码定义了一个hashmap对象并存放了10个键值对，在迭代遍历过程中，使用map的remove方法移除了一个元素，导致抛出了ConcurrentModificationException异常： 2. 多线程环境下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class FailFastTest &#123; public static List&lt;String&gt; list = new ArrayList&lt;&gt;(); private static class MyThread1 extends Thread &#123; @Override public void run() &#123; Iterator&lt;String&gt; iterator = list.iterator(); while(iterator.hasNext()) &#123; String s = iterator.next(); System.out.println(this.getName() + ":" + s); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; super.run(); &#125; &#125; private static class MyThread2 extends Thread &#123; int i = 0; @Override public void run() &#123; while (i &lt; 10) &#123; System.out.println("thread2:" + i); if (i == 2) &#123; list.remove(i); &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; i ++; &#125; &#125; &#125; public static void main(String[] args) &#123; for(int i = 0 ; i &lt; 10;i++)&#123; list.add(i+""); &#125; MyThread1 thread1 = new MyThread1(); MyThread2 thread2 = new MyThread2(); thread1.setName("thread1"); thread2.setName("thread2"); thread1.start(); thread2.start(); &#125;&#125; 启动两个线程，分别对其中一个对list进行迭代，另一个在线程1的迭代过程中去remove一个元素，结果也是抛出了java.util.ConcurrentModificationException fail-fast的原理fail-fast是如何抛出ConcurrentModificationException异常的，又是在什么情况下才会抛出?我们知道，对于集合如list，map类，我们都可以通过迭代器来遍历，而Iterator其实只是一个接口，具体的实现还是要看具体的集合类中的内部类去实现Iterator并实现相关方法。这里我们就以ArrayList类为例。在ArrayList中，当调用list.iterator()时，其源码是： 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 即它会返回一个新的Itr类，而Itr类是ArrayList的内部类，实现了Iterator接口，下面是该类的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * An optimized version of AbstractList.Itr */private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings("unchecked") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 其中，有三个属性： 123int cursor; // index of next element to returnint lastRet = -1; // index of last element returned; -1 if no suchint expectedModCount = modCount; cursor是指集合遍历过程中的即将遍历的元素的索引，lastRet是cursor -1，默认为-1，即不存在上一个时，为-1，它主要用于记录刚刚遍历过的元素的索引。expectedModCount这个就是fail-fast判断的关键变量了，它初始值就为ArrayList中的modCount。（modCount是抽象类AbstractList中的变量，默认为0，而ArrayList 继承了AbstractList ，所以也有这个变量，modCount用于记录集合操作过程中作的修改次数，与size还是有区别的，并不一定等于size）我们一步一步来看： 123public boolean hasNext() &#123; return cursor != size;&#125; 迭代器迭代结束的标志就是hasNext()返回false，而该方法就是用cursor游标和size(集合中的元素数目)进行对比，当cursor等于size时，表示已经遍历完成。接下来看看最关心的next()方法，看看为什么在迭代过程中，如果有线程对集合结构做出改变，就会发生fail-fast： 123456789101112@SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; 从源码知道，每次调用next()方法，在实际访问元素前，都会调用checkForComodification方法，该方法源码如下： 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 可以看出，该方法才是判断是否抛出ConcurrentModificationException异常的关键。在该段代码中，当modCount != expectedModCount时，就会抛出该异常。但是在一开始的时候，expectedModCount初始值默认等于modCount，为什么会出现modCount != expectedModCount，很明显expectedModCount在整个迭代过程除了一开始赋予初始值modCount外，并没有再发生改变，所以可能发生改变的就只有modCount，在前面关于ArrayList扩容机制的分析中，可以知道在ArrayList进行add，remove，clear等涉及到修改集合中的元素个数的操作时，modCount就会发生改变(modCount ++),所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使modCount发生变化，这样在checkForComodification方法中就会抛出ConcurrentModificationException异常。类似的，hashMap中发生的原理也是一样的。 避免fail-fast了解了fail-fast机制的产生原理，接下来就看看如何解决fail-fast 方法1在单线程的遍历过程中，如果要进行remove操作，可以调用迭代器的remove方法而不是集合类的remove方法。看看ArrayList中迭代器的remove方法的源码： 1234567891011121314public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125; 可以看到，该remove方法并不会修改modCount的值，并且不会对后面的遍历造成影响，因为该方法remove不能指定元素，只能remove当前遍历过的那个元素，所以调用该方法并不会发生fail-fast现象。该方法有局限性。例子： 123456789101112131415public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0 ; i &lt; 10 ; i++ ) &#123; list.add(i + ""); &#125; Iterator&lt;String&gt; iterator = list.iterator(); int i = 0 ; while(iterator.hasNext()) &#123; if (i == 3) &#123; iterator.remove(); //迭代器的remove()方法 &#125; System.out.println(iterator.next()); i ++; &#125;&#125; 方法2使用java并发包(java.util.concurrent)中的类来代替ArrayList 和hashMap。比如使用 CopyOnWriterArrayList代替ArrayList，CopyOnWriterArrayList在是使用上跟ArrayList几乎一样，CopyOnWriter是写时复制的容器(COW)，在读写时是线程安全的。该容器在对add和remove等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于CopyOnWriterArrayList在迭代过程并不会发生fail-fast现象。但 CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。对于HashMap，可以使用ConcurrentHashMap，ConcurrentHashMap采用了锁机制，是线程安全的。在迭代方面，ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据 ，iterator完成后再将头指针替换为新的数据 ，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。即迭代不会发生fail-fast，但不保证获取的是最新的数据。参考链接：http://www.jb51.net/article/84468.htmhttp://www.cnblogs.com/ccgjava/p/6347425.html?utm_source=itdadao&amp;utm_medium=referral]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>集合</tag>
        <tag>fail-fast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈ArrayList动态扩容]]></title>
    <url>%2F2017%2F10%2F23%2F%E6%B5%85%E8%B0%88ArrayList%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[环境eclipsejdk1.8 简介ArrayList实现了List接口，继承了AbstractList，底层是数组实现的，一般我们把它认为是可以自增扩容的数组。它是非线程安全的，一般多用于单线程环境下(与Vector最大的区别就是，Vector是线程安全的，所以ArrayList 性能相对Vector 会好些)，它实现了Serializable接口，因此它支持序列化，能够通过序列化传输(实际上java类库中的大部分类都是实现了这个接口的)，实现了RandomAccess接口，支持快速随机访问(只是个标注接口，并没有实际的方法),这里主要表现为可以通过下标直接访问(底层是数组实现的，所以直接用数组下标来索引)，实现了Cloneable接口，能被克隆。ArrayList：RandomAccess 初始化ArrayList一共提供了三个初始化的方法： 123public ArrayList()public ArrayList(Collection&lt;? extends E&gt; c)public ArrayList(int initialCapacity)； 首先看看源码里无参构造方法的实现：上面的注释表示他会默认提供容量为10的数组，但是实际并不是在这一步实现。可以看看这里的DEFAULTCAPACITY_EMPTY_ELEMENTDATA和elementData：只是一个空数组。所以这一步实际上只是将elementData指向一个空数组而已。再来看看带参数的构造方法：这个方法是直接将一个集合作为ArrayList的元素，很容易看懂，不多做解释，此时elementData即为集合c转为的数组，size即为elementData的长度。这里size是ArrayList的一个int型私有变量，用于记录该list集合中当前元素的数量，注意不是容量。再来看看带初始化容量的构造方法：从源码里可以看出：首先对传进来的初始化参数initialCapacity进行判断，如果该参数大于0，在elementData进行初始化，初始化为一个容量为initialCapacity的数组，如果传进来的参数initialCapacity等于0，则将elementData指向了EMPTY_ELEMENTDATA，从这个名字也可以猜出，是个空数组： add方法的实现说了这么多，还没有说到无参构造函数默认是空数组，为什么注释说是容量为10的数组，也还没说到当容量不足时，是如何实现动态扩容的，下面就通过add方法来说明这些问题。(add方法是list接口中声明的通用方法)。ArrayList的add方法实现如下：size是当前集合拥有的元素个数(未算进准备新增的e元素)，从源码看出，调用了ensureCapacityInternal来保证容量问题，传进去的参数是size+1，来保证新增元素后容量满足要求。接下来进入ensureCapacityInternal方法查看其实现：可以看到代码段： 123if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);&#125; 通过这一步来判断，当前elementData是否为空数组(即初始化容量为0或者调用了无参构造函数后的结果)，如果是，则使用Math.max(DEFAULT_CAPACITY, minCapacity)进行选择一个较大的，其中，DEFAULT_CAPACITY是ArrayList定义的静态常量10：可以看出，这里如果minCapacity小于10的话(如果elementData为空的话，size+1即minCapacity一般为1)，返回的是10，所以如果没有指定大小的话，默认是初始化一个容量为10的数组。然后在调用ensureExplicitCapacity方法：可以看到modCount++，这里可以暂时不管它，这个参数主要是用在集合的Fail-Fast机制(即快速失败机制)的判断中使用的。(以后有空再补充这方面的内容)在这个方法里进行判断，新增元素后的大小minCapacity是否超过当前集合的容量elementData.length，如果超过，则调用grow方法进行扩容。我们进入该方法进行查看:在这里可以很清楚的看到扩容容量的计算:int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),其中oldCapacity是原来的容量大小，oldCapacity &gt;&gt; 1 为位运算的右移操作，右移一位相当于除以2，所以这句代码就等于int newCapacity = oldCapacity + oldCapacity / 2；即容量扩大为原来的1.5倍(注意我这里使用的是jdk1.8，没记错的话1.7也是一样的)，获取newCapacity后再对newCapacity的大小进行判断，如果仍然小于minCapacity，则直接让newCapacity 等于minCapacity，而不再计算1.5倍的扩容。然后还要再进行一步判断，即判断当前新容量是否超过最大的容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0)，如果超过，则调用hugeCapacity方法，传进去的是minCapacity，即新增元素后需要的最小容量：如果minCapacity大于MAX_ARRAY_SIZE，则返回Integer的最大值。否则返回MAX_ARRAY_SIZE。然后回到grow方法，调用Arrays.copyof方法，即复制原数组内容到一个新容量的大数组里。这里Arrays.copyof方法实际是调用System.arraycopy方法。到这里，应该可以很清楚的知道ArrayList底层扩容的原理了。与Vector不同的是，Vector每次扩容容量是翻倍，即为原来的2倍，而ArrayList是1.5倍。看似1.5倍增长的很慢，那经常增加大量元素会不会导致经常扩容，数组重新分配导致效率低下呢？其实不然，每次增长为原来的1.5倍实际增长的量会越来越大的，可以看看网友统计的数据(参考：http://blog.csdn.net/java2000_net/article/details/5215882)： 1千需要分配 11次1万一级需要分配17次10万 需要分配23次100万需要分配28次 当然，如果一开始知道数据量很大的话，可以在初始化时预先指定容量。 get方法很明显是通过数组下标索引来指定返回的数组，这里不多做解释。 验证无参构造函数，add三个元素，按照理解，此时默认容量应该为10：可以看出：elementData容量为10，size为3。 无参构造函数，增加12个元素：测试代码： 123456List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0 ; i &lt; 12; i ++) &#123; list.add(i); &#125; System.out.println("ok"); 通过debug查看结果：看到elementData扩容为15(10+10/2 = 15),而集合元素size为12。 无参构造函数，增加原来的1.5倍扩容量的数据：测试代码： 12345678910List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); List&lt;Integer&gt; newList = new ArrayList&lt;&gt;(); for (int i = 0 ; i &lt; 5; i ++) &#123; 初始5个 list.add(i); &#125; for (int i = 5 ; i &lt; 20; i ++) &#123; newList.add(i); &#125; list.addAll(newList); //一次性增加15个 System.out.println("ok"); 正常情况下，新增5个后，容量为10，再次新增，会变为原来的1.5倍，即15，但是这里新增15个，明显超过，按照上面的理解，应该直接让新容量等于需要的最小容量20，从测试截图可以看到，结果正确。 带集合参数构造函数：测试代码： 123456List&lt;Integer&gt; newList = new ArrayList&lt;&gt;();for (int i = 5 ; i &lt; 20; i ++) &#123; newList.add(i);&#125;List&lt;Integer&gt; list = new ArrayList&lt;&gt;(newList);System.out.println("ok"); 测试结果：可以看到，结果elementData的容量即为集合参数的大小。 总结总之，ArrayList默认容量是10，如果初始化时一开始指定了容量，或者通过集合作为元素，则容量为指定的大小或参数集合的大小。每次扩容为原来的1.5倍，如果新增后超过这个容量，则容量为新增后所需的最小容量。如果增加0.5倍后的新容量超过限制的容量，则用所需的最小容量与限制的容量进行判断，超过则指定为Integer的最大值，否则指定为限制容量大小。然后通过数组的复制将原数据复制到一个更大(新的容量大小)的数组。 附size和modCount的区别可能看了源码有时候还分不清size和modCount的区别，那么这里就用例子来说明。size是ArrayList的变量。modCount是ArrayList的父类AbstractList中的变量，默认值为0。size记录了ArrayList中元素的数量，modCount记录的是关于元素的数目被修改的次数。modCount在ArrayList的普通操作里可能并没有看出多大用处，但是在涉及到fail-fast就主要是依靠它了。直接用下面这段代码进行测试： 12345678910List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.remove(2); list.add(5); list.set(1, 100); list.remove(4); System.out.println(list.size()); 当执行完 list.add(4)时，此时modCount和size都为4：当执行完list.remove(2)时，此时元素数量发生了修改，所以modCount++即5,而size记录集合中元素的个数，移除了一个后，size=size-1即3：当执行完list.add(5)时，此时元素数量再次发生了修改，所以modCount++即5,而size记录集合中元素的个数，增加了一个后，size=size-1即4：当执行完list.set(1, 100)时，元素的数量并没有发生改变，所以modCount和size都不变。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>java</tag>
        <tag>arraylist</tag>
        <tag>扩容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java泛型中的&lt;? extends E&gt;和&lt;? super E&gt;的区别]]></title>
    <url>%2F2017%2F09%2F23%2F%E6%B5%85%E8%B0%88Java%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%20extends%20E%E5%92%8C%20super%20E%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[引入再说这个之前，先来看一段代码：假设有这么几个类及其继承关系，后面的例子也用这几个类作为基础示范 123456789101112class People &#123; //人&#125;class Man extends People &#123; //男人&#125;class Woman extends People &#123; //女人&#125;class Boy extends Man &#123; //男孩&#125; 可以看到，man是people的子类，那么： 1List&lt;People&gt; list= new ArrayList&lt;Man&gt;(); 是否可以编译通过？很明显，编译的时候报错了。man是people的子类，ArrayList是List的子类，但并不代表List是List的子类。所以便有了有限通配符 &lt;? extends E&gt;&lt;? extends E&gt; 是 Upper Bound（上限） 的通配符，用来限制元素的类型的上限，比如： 1List&lt;? extends People&gt; list_1 = null; 表示集合中的元素上限是People，即只能是People或People的子类，所以下面的赋值是合法的，编译时候不会报错：但不能是其父类，否则编译时候就报错了：接下来对其读写数据进行了解： 读不管给该list_1如何赋值，可以保证的是里面存放的一定是People或People的子类，编译器可以确定获取的是People类型，所以可以直接从该集合中读取到People类型。即读取是允许的。 写People、Man、Woman都是People类或其子类，但是这里却是编译错误的。原因是? extends People&gt;仅仅告诉编译器该集合元素类型上限是People，这里编译器并不能确定具体的类型，即它可能实际指向了Man，但是你却add一个Woman类型，所以这里编译器不允许这么做。 &lt;? super E&gt;&lt;? super E&gt; 是 Lower Bound（下限） 的通配符 ，用来限制元素的类型下限，比如： 1List&lt;? super Man&gt; list_4 = null; 该表示给出了集合中元素的下限是Man，即只能为Man或者Man的父类，而不能是Man的子类，如下：接下来对其读写数据进行了解： 读允许从该集合获取元素，但是无法保证里面存放的是Man或者是Woman，唯一可以确定的是存放的是Object或其子类，而无法确定具体的类型。这样都没错，但是实际用的时候还是要注意，像这样获取Woman可能导致异常。 写可以确定的是集合中的元素一定是Man或Man的子类，所以添加Man或Boy都是正确的，但是不能添加非Man的子类： 使用场景很多时候都是用它来当作方法中的形参。这里先了解下PECS法则 PECSPECS指“Producer Extends，Consumer Super”。换句话说，如果参数化类型表示一个生产者，就使用&lt;? extends T&gt;；如果它表示一个消费者，就使用&lt;? super T&gt; 例子这里使用网上常见的例子水果来说明，有如下关系：假设此时有个水果供应商Produce， 12345678class Produce&lt;E&gt; &#123; public void produce(List&lt;E&gt; list) &#123; for (E e : list) &#123; //生产... System.out.println("批量生产..."); &#125; &#125;&#125; 它主要销售水果 123Producer&lt;Pear&gt; p = new Produce&lt;&gt;();List&lt;Pear&gt; pears = new ArrayList&lt;Pear&gt;();p.produce(pears); 这样并没有什么问题。但是万一他突然想换成销售苹果了，此时：这样就会发现，编译并不能通过，因为List已经在初始化时确定为Pear了，而不再兼容Appler类型，即使你最开始使用的是Produce，即方法produce的参数list为List，虽然Apple和Pear是Fruit的子类，但是由上面的引入知识知道，List并不是List的父类，即这样也是行不通的，所以这里就需要使用List&lt;? extends E&gt; list了。修改后如下： 12345678class Producer&lt;E&gt; &#123; public void produce(List&lt;? extends E&gt; list) &#123; for (E e : list) &#123; //利用&lt;? extends E&gt;读取的特性 //生产... &#125; System.out.println("批量生产完成..."); &#125;&#125; 此时只要供应商new的时候为Fruit，则生产的货物只要为Fruit或其子类即可，所以Pear和Apple都可通过。如下：接着举一个消费者的例子(可能例子举得不是很好) 1234567//消费者class Consumer&lt;E&gt; &#123; public E consume(List&lt;E&gt; list) &#123; E e = list.get(0); //模拟消费一个(感觉用队列比较合适) return e; &#125;&#125; 每次消费者都从一个list中消费一个。加入有一个红苹果消费者：这里是没什么问题的，但是红苹果也是苹果，如果这样呢：这时候，&lt;? super E&gt;派上用场了。 1234567//消费者class Consumer&lt;E&gt; &#123; public E consume(List&lt;? super E&gt; list) &#123; E e = (E) list.get(0); //模拟消费一个(感觉用队列比较合适) return e; &#125;&#125; 此时再按刚才的操作：编译并不会出问题了。 其实，在java提供的许多类库里就有用到了，比如Collections的静态方法copy：为了保证在list复制过程中类型的安全，限制了原list的上限，保证了目标数组的下限。 参考链接：https://www.cnblogs.com/wangmingshun/p/5389341.html http://blog.csdn.net/asdfsadfasdfsa/article/details/52794573]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈夫曼树与哈夫曼编码]]></title>
    <url>%2F2017%2F09%2F22%2F%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[哈夫曼树哈夫曼树又称最优二叉树, 是一种带权路径长度最短的二叉树。在这个二叉树中，只有叶子节点才是有效的数据节点,其他只是作为路径而构造的。 带权路径长度又称WPL，树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度，即树中所有叶节点的带权路径长度之和。WPL= (W1L1+W2L2+W3L3+…+WnLn)， N个权值Wi(i=1,2,…n)构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li(i=1,2,…n)。可以证明哈夫曼树的WPL是最小的。 哈夫曼编码哈夫曼编码是哈夫曼树的一个应用。哈夫曼编码主要是起到压缩的作用。哈夫曼编码应用广泛，如JPEG中就应用了哈夫曼编码。 构建哈夫曼树和获得哈夫曼编码以及WPL的计算下面用一道题来说明构建哈夫曼树和获得哈夫曼编码的过程： 若以{4,5,6,7,8}作为叶子结点的权值构造哈夫曼树，则其带权路径长度是（） 构造哈夫曼树首先，从4，5，6，7，8 （为了方便，将这个数组称为a）中找到最小的两个数4和5，作为叶子结点（一般按照左小右大的方式）：得到新结点权值 9（4+5=9）,从将9加入到剩余的数中，即此时a为6，7，8，9从中再找到最小的2个数6，7，构造树为：得到新结点权值 13（6+7=13）,从将13加入到剩余的数中，即此时a为13，8，9，从剩余的数中找到最小的2个数8和9，构造数为：得到新结点权值17（8+9=17）,从将17加入到剩余的数中，即此时a为13，17.最后这两个节点构成根结点：此时哈夫曼树构造完成了。那么哈夫曼编码怎么算呢？按左小右大就是结点的左边连线为0，右边为1，即： 获取哈夫曼编码：则相应数（可以看到叶子结点就是原先数组a中的数），所以只需遍历叶子结点，对每个结点，从根结点往下，直到该叶子结点的路径对应的数，即为该数的哈夫曼编码。如上图得到的哈夫曼编码分别为：8：004：0105：0116：107：11WPL的计算：叶节点的带权路径长度之和。对本题：权值4和权值5的路径长度为3，7，8，9的长度都为2， 所以WPL为：（4+5）*3+（6+7+8）*2 = 69]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>哈夫曼</tag>
        <tag>哈夫曼编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis中的#和$的区别]]></title>
    <url>%2F2017%2F09%2F22%2Fmybatis%E4%B8%AD%E7%9A%84-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[简介MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 动态 sql 是 mybatis 的主要特性之一，在mybatis中我们可以把参数传到xml文件，由mybatis对sql及其语法进行解析，mybatis支持使用${}和#{}。可能有些人没有留意到，认为${}和#{}的作用一样，其实他们的功能相似，但还是有区别的。 对比1、使用${}方式传入的参数，mybatis不会对它进行特殊处理，而使用#{}传进来的参数，mybatis默认会将其当成字符串。可能在赋值给如id=#{id}和id=${id}看不出多大区别，但是作为表名或字段参数时可以明显看出，可以看看下面的例子： 假设传入的参数为表名test 1selec * from #&#123;table&#125;; 解析后是： 1select * from "test"; 而 1select * from $&#123;table&#125;; 解析后是： 1select * from test; 很明显，前者多了字符串的引号，会失败，后者正常查询会成功； 所以对于传入分组(order)字段或者排序字段(order)，应使用${},避免出现order by “id” 等情况。 2、#和$在预编译处理中是不一样的。#类似jdbc中的PreparedStatement，对于传入的参数，在预处理阶段会使用?代替，比如： 1select * from student where id = ?; 待真正查询的时候即在数据库管理系统中（DBMS）才会代入参数。 而${}则是简单的替换，如下： 1select * from student where id = 2; 总结1、能使用#{}的地方应尽量使用#{} 2、像PreparedStatement ，#{}可以有效防止sql注入，${}则可能导致sql注入成功。 所谓sql注入，就是指把用户输入的数据拼接到sql语句后面作为sql语句的一部分执行，例如： 1select * from user where name=' "+name+" ' and password=' "+password+" ' 那么只要用户输入用户名admin和密码123456’ or ‘abc’ = ‘abc’,那么拼接出来的语句就为 1select * from user where name=' admin ' and password='123456' or 'abc'= 'abc'; 这样只要user表有数据，就会返回结果，达到sql注入的目的。同样，用户输入用户名a’则 and password=’ “+password+” ‘就会被注释掉，也达到注入sql的目的。 附这里顺带提下防止sql注入的几种方式(可能不止这几种):(1)、jdbc使用 PreparedStatement代替Statement， PreparedStatement 不仅提高了代码的可读性和可维护性.而且也提高了安全性，有效防止sql注入；(2)、在程序代码中使用正则表达式过滤参数。使用正则表达式过滤可能造成注入的符号，如’ –等 (3)、在页面输入参数时也进行字符串检测和提交时进行参数检查，同样可以使用正则表达式，不允许特殊符号出现。]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>j2ee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死锁的定义、产生原因、必要条件和处理方法]]></title>
    <url>%2F2017%2F09%2F20%2F%E6%AD%BB%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E3%80%81%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[死锁的定义在一组进程发生死锁的情况下，这组死锁进程中的每个进程，都在等待另一个死锁进程所占有的资源。死锁的定义如下： 如果一个进程中的每一个进程都在等待仅该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。 死锁的产生原因死锁的起因，通常是源于多个进程对资源的争夺，不仅对不可抢占资源进行争夺或引起死锁，而且对可消耗资源进行争夺也会引起死锁。总结如下： 1、系统资源不足； 2、进程运行推进的顺序不当； 3、资源分配不当； 死锁产生的必要条件1、互斥条件：进程在运行中对资源进行排他性使用，即一个资源仅能被一个进程使用，此时其他进程请求资源时，只能等待其释放。2、请求与保持条件：某进程已经保持了一个资源，但又请求另一个资源，若该资源被其他进程占有，此时请求阻塞，且对已经占有的资源不释放；3、不可抢占条件：进程获得的资源在未使用完时不可被抢占，只能在进程使用完时自己释放； 4、循环等待条件：发生死锁时，必然存在这样一个循环，一个进程p1等待p2占有的资源进程p2等待p3占有的资源…进程pn等待p1占有的资源。 死锁的处理方法1、预防死锁：事先预防策略，容易实现，通过实现设置限制，破坏产生死锁的四个条件之一。(如对资源采用按序分配策略)2、避免死锁：事先预防策略，在资源的动态分配过程中，用某些方法防止系统禁图不安全状态。常见的方法有银行家算法。3、检测死锁：通过检测机构等及时检测出死锁，采取适当措施，把进程从死锁中解脱。4、解除死锁：检测出死锁后，采取措施解决。比如剥夺资源，撤销进程。这四种方法对死锁的防范逐渐减弱，但对应的是资源利用率的提高。 参考自：《计算机操作系统》第四版]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中非静态内部类可以有常量但不能有staic修饰的属性]]></title>
    <url>%2F2017%2F09%2F20%2Fjava%E4%B8%AD%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%B8%B8%E9%87%8F%E4%BD%86%E4%B8%8D%E8%83%BD%E6%9C%89staic%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[先看下面的代码： 123456789101112131415package com.howard.test;/** * java中非静态内部类不能有staic修饰的属性，但可以有常量 * 2017年9月12日 * @author hongwu */public class Test2 &#123; public static void main(String[] args) &#123; int a; class innerClass &#123; static int b = 0; //编译不通过 static final int c = 1; //编译通过 &#125; &#125;&#125; java类加载顺序，首先加载类，执行static变量初始化，接下来执行对象的创建，这里的innerClass是非静态内部类，非静态内部类，依赖于一个外部类对象，而静态域/方法是不依赖于对象——仅与类相关，也就是说，这里如果在初始化变量b时，需要依赖于外部类的实例化，外部类还没创建，所以这里的static int b是无法初始化的，而static final int c = 1 不同（static可有可无），他是一个常量，而常量jvm在编译期就确定下来并将它放在常量池的，所以这里可以不会报错。再看下面的代码： 123456class Test2_2 &#123; static class innerClass &#123; static int b = 0; //编译通过 static final int c = 1; //编译通过 &#125;&#125; 这里两个都不会报错，与上面的区别是这里的内部类是静态内部类，静态内部类是不依赖于外部类的实例化的，所以这里的static int b是不会报错的。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>java</tag>
        <tag>静态</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大奇约数]]></title>
    <url>%2F2017%2F08%2F31%2F%E6%9C%80%E5%A4%A7%E5%A5%87%E7%BA%A6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.howard.algorithm.test; import java.util.Scanner;/** * 小易是一个数论爱好者，并且对于一个数的奇数约数十分感兴趣。一天小易遇到这样一个问题： 定义函数f(x)为x最大的奇数约数，x为正整数。 例如:f(44) = 11. * 现在给出一个N，需要求出 f(1) + f(2) + f(3).......f(N) * 例如： N = 7 * f(1) + f(2) + f(3) + f(4) + f(5) + f(6) + f(7) = 1 + 1 + 3 + 1 + 5 + 3 + 7 = 21 * 小易计算这个问题遇到了困难，需要你来设计一个算法帮助他。 * 2017年8月17日 * @author howard */public class MaxOddSubmultiple &#123; public static void main(String[] args) &#123;// int num = 7; Scanner scanner = new Scanner(System.in); int num = scanner.nextInt(); scanner.close(); int result = 0; for (int i = 1 ; i &lt;= num; i ++ ) &#123; result += getMaxOddSubmultiple(i); &#125; System.out.println(result); &#125; public static int getMaxOddSubmultiple(int num) &#123; int result = 1; if (num % 2 != 0) return num; else &#123; int y = (int) Math.sqrt(num); if (y % 2 == 0) &#123; return y; &#125; for (int i = y - 1 ; i &gt;= 1; i -= 2) &#123; if (num % i == 0) &#123; result = i; break; &#125; &#125; &#125; return result; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交错01串]]></title>
    <url>%2F2017%2F08%2F31%2F%E4%BA%A4%E9%94%9901%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142package com.howard.algorithm.test; import java.util.Scanner;/** * [编程题] 交错01串 * 时间限制：1秒 * 空间限制：32768K * 如果一个01串任意两个相邻位置的字符都是不一样的,我们就叫这个01串为交错01串。例如: "1","10101","0101010"都是交错01串。 * 小易现在有一个01串s,小易想找出一个最长的连续子串,并且这个子串是一个交错01串。小易需要你帮帮忙求出最长的这样的子串的长度是多少。 * 输入描述：输入包括字符串s,s的长度length(1 ≤ length ≤ 50),字符串中只包含'0'和'1' * 输出描述:输出一个整数,表示最长的满足要求的子串长度。 * 输入例子：111101111 * 输出例子：3 * 2017年8月15日 * @author howard */public class MaxSubStringWith0Or1 &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String s = in.next(); in.close(); //String s = "1000001101"; int max = 0; int tmp = 1; for (int i = 1 ; i &lt; s.length(); i ++ ) &#123; if (s.substring(i, i+1).equals(s.substring(i-1,i))) &#123; if (max &lt; tmp) &#123; max = tmp; &#125; tmp = 1; &#125;else &#123; tmp ++ ; if (i == (s.length() - 1)) &#123; if (max &lt; tmp) &#123; max = tmp; &#125; &#125; &#125; &#125; System.out.println(max); &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字翻转]]></title>
    <url>%2F2017%2F08%2F31%2F%E6%95%B0%E5%AD%97%E7%BF%BB%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.howard.algorithm; import java.util.ArrayList;import java.util.List;import java.util.Scanner;/** * [编程题] * 时间限制：1秒 * 空间限制：32768K * 对于一个整数X，定义操作rev(X)为将X按数位翻转过来，并且去除掉前导0。例如: * 如果 X = 123，则rev(X) = 321; * 如果 X = 100，则rev(X) = 1. * 现在给出整数x和y,要求rev(rev(x) + rev(y))为多少？ * 输入描述: * 输入为一行，x、y(1 ≤ x、y ≤ 1000)，以空格隔开。 * 输出描述: * 输出rev(rev(x) + rev(y))的值 * 输入例子1:123 100 * 输出例子1:223 * * 2017年8月12日 * @author howard */public class RevNum &#123; public static int rev(int num) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int newNum = 0; while (num &gt; 0) &#123; int x = num%10; num = num/10; list.add(x); &#125; int z = 1; for (int i = list.size() - 1 ; i &gt;= 0 ; i -- ) &#123; newNum += list.get(i) * z; z *= 10; &#125; return newNum; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int x = scanner.nextInt(); int y = scanner.nextInt(); System.out.println(rev(rev(x) + rev(y))); scanner.close(); &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven项目中手动安装jar包到自己本地仓库]]></title>
    <url>%2F2016%2F05%2F26%2Fmaven%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85jar%E5%8C%85%E5%88%B0%E8%87%AA%E5%B7%B1%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[问题maven项目pom中引用memcached的依赖包 12345&lt;dependency&gt; &lt;groupId&gt;com.danga&lt;/groupId&gt; &lt;artifactId&gt;memcached&lt;/artifactId&gt; &lt;version&gt;2.6.6&lt;/version&gt;&lt;/dependency&gt; 发现并没有成功下载jar包 弄了好久，查看网上资料结果是: 由于目前java memcached client没有官方的maven repository可供使用，因此使用时需要手动将其安装到本地repository。 安装jar到本地仓库这里以memcached为例。其它jar安装方式类似。 先去官网或者其它网站下载需要的jar包，放在某目录下。这里假设为E:/a/java_memcached-release_2.6.6.jar 打开cmd输入： 1mvn install:install-file -Dfile=e:/a/java_memcached-release_2.6.6.jar -DgroupId=com.danga -DartifactId=memcached -Dversion=2.6.6 -Dpackaging=jar -DgeneratePom=true 显示安装成功，就可以成功在eclipse用上面的pom语句来引入memcached的jar包 -DgroupId=com.danga -DartifactId=memcached -Dversion=2.6.6 -Dpackaging=jar -DgeneratePom=true上面这行表示为安装的jar包设置一个pom坐标之后我们在eclipse的项目里pom引用这个jar包要遵循这个坐标 其他jar包安装方法类似]]></content>
      <categories>
        <category>踩过的坑</category>
      </categories>
      <tags>
        <tag>jdk</tag>
        <tag>踩过的坑</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos6.5安装tomcat8步骤]]></title>
    <url>%2F2016%2F05%2F22%2Fcentos6-5%E5%AE%89%E8%A3%85tomcat8%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[安装说明安装环境：CentOS-6.5 安装方式：源码安装 软件：apache-tomcat-8.0.29.tar.gz 下载地址：http://tomcat.apache.org/download-70.cgi 安装路径：/usr/local 安装前提系统必须已经安装配置了JDK6+ 安装tomcat将apache-tomcat-8.0.29.tar.gz文件上传到/usr/local中执行以下操作： 1234[root@admin local]# cd /usr/local[root@admin local]# tar -zxv -f apache-tomcat-8.0.29.tar.gz // 解压压缩包 [root@admin local]# rm -rf apache-tomcat-8.0.29.tar.gz // 删除压缩包 [root@admin local]# mv apache-tomcat-8.0.29 tomcat 启动tomcat执行以下操作： 123456[root@admin ~]# /usr/local/tomcat/bin/startup.sh //启动tomcatUsing CATALINA_BASE: /usr/local/tomcatUsing CATALINA_HOME: /usr/local/tomcatUsing CATALINA_TMPDIR: /usr/local/tomcat/tempUsing JRE_HOME: /usr/java/jdk1.7.0/jreUsing CLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar 出现以上的打印信息说明已经成功启动。 验证安装防火墙需要开放8080端口（如果需要外部浏览器访问的话）： 1vim /etc/sysconfig/iptables 新增以下代码： 12 重启防火墙： 1service iptables restart 浏览器输入如下地址验证：http://192.168.1.107:8080/ 其中192.168.1.107为linux机器的ip。 也可以输入curl http://localhost:8080/查看 看到tomcat界面，恭喜，安装成功！ 停止tomcat1/usr/local/tomcat/bin/shutdown.sh]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>centos</tag>
        <tag>教程</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux配置永久ip不生效解决方法]]></title>
    <url>%2F2016%2F05%2F21%2Flinux%E9%85%8D%E7%BD%AE%E6%B0%B8%E4%B9%85ip%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[linux下使用ifconfig eth0 ip地址可以设置ip地址 ，但并不能永久生效 如果想要永久生效，输入命令setup打开图形界面，设置相应ip和DNS后保存即可但是可能你会发现即使service network start 即重启网络后可能输入ifconfig也看不到eth0网卡的信息，说明并没有生效，这时就应该通过如下方式开启网卡。 输入命令： 1vi /etc/sysconfig/network-scripts/ifcfg-eth0 打开vim文本编辑器 修改如下 将eth0网卡的ONBOOT=no修改为ONBOOT=yes 将BOOTPROTO=no修改为BOOTPROTO=yes 再保存，即可]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>踩过的坑</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下卸载自带jdk以及安装jdk]]></title>
    <url>%2F2016%2F05%2F20%2Flinux%E4%B8%8B%E5%8D%B8%E8%BD%BD%E8%87%AA%E5%B8%A6jdk%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85jdk%2F</url>
    <content type="text"><![CDATA[JDK 1.7 下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html一般都要先卸载linux自带的openjdk版本的jdk 卸载自带jdk卸载步骤：这里写的是centos的卸载方法，其他类型linux系统可能有些许区别第一步：查看Linux自带的JDK是否已安装安装好的CentOS会自带OpenJdk,用命令 Java -version ，会有下面的信息：java version “1.6.0”OpenJDK Runtime Environment (build 1.6.0-b09)OpenJDK 64-Bit Server VM (build 1.6.0-b09, mixed mode)最好还是先卸载掉openjdk,再安装sun公司的jdk. 先查看 rpm -qa | grep java 显示如下信息： 12java-1.4.2-gcj-compat-1.4.2.0-40jpp.115java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5 卸载命令： 12yum -y remove java java-1.4.2-gcj-compat-1.4.2.0-40jpp.115yum -y remove java java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5 如果发现系统还有带了如下安装（ rpm -qa | grep java）： 12 输入如下命令卸载： 1rpm -e --nodeps tzdata-java-2013g-1.el6.noarch 验证是否已经卸载： 12java -versionjavac -version 如果上面两条命令都没有输出jdk相关信息，证明卸载成功 安装JDK这里我以jdk1.7为例，安装目录以usr/local为例，将下载好的安装包解压： 12 如果不在相应的目录下，通过mv移到到需要的目录 修改环境变量： 1vim /etc/profile 添加： 123export JAVA_HOME=/usr/local/jdk1.7.0_25 export CLASSPATH=/usr/local/jdk1.7.0_25/lib export PATH=$JAVA_HOME/bin:$PATH 如果你不想重启系统，可以用命令source /etc/profile使配置文件立即生效。否则只能重启系统才能使配置参数生效： 1source /etc/profile 接着验证环境变量是否生效： 12345678[root@localhost ~]# echo $JAVA_HOME /usr/java/jdk1.7.0_25 [root@localhost ~]# echo $PATH /usr/java/jdk1.7.0_25/bin:/usr/kerberos/sbin:/usr/kerberos/bin :/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/X11R6/bin:/root/bin [root@localhost ~]# echo echo $CLASSPATH /usr/java/jdk1.7.0_25/lib [root@localhost ~]# 最后， 验证安装成功与否，以及环境变量是否生效： 12java -versionjavac -version 输出相应的版本信息，说明安装成功。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>教程</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主机无法访问虚拟机Linux的apache]]></title>
    <url>%2F2016%2F05%2F18%2F%E4%B8%BB%E6%9C%BA%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BALinux%E7%9A%84apache%2F</url>
    <content type="text"><![CDATA[在虚拟机linux里安装了httpd，即appache，启动后，按正常情况在主机是可以用浏览器通过访问虚拟机linux的ip来访问的。如果出现无法访问的情况，解决办法可以参考如下：这里我的虚拟机联网方式为物理连接，且ip与主机不同，但在同一网段。1、先确定虚拟机可不可以访问外网，可通过ping www.baidu.com 测试，如果不行，先百度或者参考其他资料或setup自行配置好ip相关信息（当然，前提是你主机联网了）2、主机与虚拟机通过各自ip互ping ，如果主机可以ping虚拟机，而虚拟机却不可以ping主机，考虑下是不是主机电脑防火墙没有关，很多情况是这个原因，关闭防火墙可以解决。3、如果以上都没问题，还是没能解决，则可能是iptable的限制。通过如下命令把tcp的80端口配置为允许任何ip访问就可以了命令: 1iptables -I INPUT -p TCP --dport 80 -j ACCEPT 注意linux的命令是区分大小写的 但是，上面第三步的方法只是临时生效的，只要你重启了虚拟机或者说重启了linux，就必须重新设置才可以访问，解决办法如下：在命令行下输入： 1vi /etc/selinux/config 会打开vi编辑器修改文件：将SELINUX=enforcing这一行注释掉，并且加上一行，如下： 12#SELINUX=enforcingSELINUX=disabled 再保存，后继续输入命令： 12[root@Fedora6 ~]# chkconfig --level 3 iptables off[root@Fedora6 ~]# chkconfig --level 5 iptables off 之后重启linux，生效，就可以了 这时主机就可以访问虚拟机开启的apache了（这里只是用apache示例，应该说可以同主机浏览器访问虚拟机ip了）]]></content>
      <categories>
        <category>踩过的坑</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>虚拟机</tag>
        <tag>apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建好maven项目后运行时出现异常时解决方法参考]]></title>
    <url>%2F2016%2F05%2F14%2F%E5%9C%A8%E6%9E%84%E5%BB%BA%E5%A5%BDmaven%E9%A1%B9%E7%9B%AE%E5%90%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[在构建好maven项目后运行时出现-Dmaven.multiModuleProjectDirectory system property is not set. Check $M2_HOME environment variable and mvn script match. 解决方法参考：eclipse点击window-&gt;perferences-&gt;java-&gt;install jres 选择你使用的jdk，点击右边的edit，出现如下界面：在箭头处输入如下：-Dmaven.multiModuleProjectDirectory=$M2_HOME点击Finish就好了。]]></content>
      <categories>
        <category>踩过的坑</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>j2ee</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加上事务aop后项目启动报错解决方法参考]]></title>
    <url>%2F2016%2F05%2F04%2F%E5%8A%A0%E4%B8%8A%E4%BA%8B%E5%8A%A1aop%E5%90%8E%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[很多时候在进行ssm或者ssh整合时会遇到各种搞不清的报错 下面就是我在整合过程遇到的错误，费了好一番功夫才知道错在哪 希望对大家有帮助 在整合中的spring配置文件里 各项我都测试没问题，这时我就加上了aop事务管理 123456789101112131415161718192021222324&lt;!-- 事务管理 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt; &lt;!-- 配置事务通知 --&gt;&lt;tx:advice id="advice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 默认只处理运行时异常，可加rollback-for="Exception/Throwable"等处理所有异常或包括错误 --&gt; &lt;tx:method name="insert*" propagation="REQUIRED" rollback-for="Exception" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" rollback-for="Exception" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" rollback-for="Exception" /&gt; &lt;tx:method name="*" propagation="SUPPORTS" /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置切面织入的范围,后边要把事务边界定在service层 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="advice" pointcut="execution(* com.hw.service.Imp.*.*(..))" /&gt;&lt;/aop:config&gt; 但是当下面这段代码加上去的时候就连启动都报了错 12345&lt;!-- 配置切面织入的范围,后边要把事务边界定在service层 --&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref="advice" pointcut="execution(* com.hw.service.Imp.*.*(..))" /&gt;&lt;/aop:config&gt; 报错如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394五月 04, 2016 10:21:48 上午 org.apache.catalina.core.StandardContext listenerStart严重: Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListenerorg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'userServiceImp' defined in file [E:\javaee\.metadata\.plugins\org.eclipse.wst.server.core\tmp4\wtpwebapps\scm1.2\WEB-INF\classes\com\hw\service\Imp\UserServiceImp.class]: BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0': Initialization of bean failed; nested exception is java.lang.NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld$ReflectionWorldException at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:452) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:293) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:290) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:192) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:585) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:895) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:425) at org.springframework.web.context.ContextLoader.createWebApplicationContext(ContextLoader.java:282) at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:204) at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:47) at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4729) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5167) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1408) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1398) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745)Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0': Initialization of bean failed; nested exception is java.lang.NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld$ReflectionWorldException at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:527) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:293) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:290) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:196) at org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans(BeanFactoryAdvisorRetrievalHelper.java:86) at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findCandidateAdvisors(AbstractAdvisorAutoProxyCreator.java:100) at org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator.shouldSkip(AspectJAwareAdvisorAutoProxyCreator.java:107) at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessBeforeInstantiation(AbstractAutoProxyCreator.java:278) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:848) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:820) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:446) ... 19 moreCaused by: java.lang.NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld$ReflectionWorldException at java.lang.Class.getDeclaredConstructors0(Native Method) at java.lang.Class.privateGetDeclaredConstructors(Class.java:2663) at java.lang.Class.getDeclaredConstructors(Class.java:2012) at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors(AutowiredAnnotationBeanPostProcessor.java:230) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineConstructorsFromBeanPostProcessors(AbstractAutowireCapableBeanFactory.java:930) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:903) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:485) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:270) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:125) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1325) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1086) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:517) ... 31 moreCaused by: java.lang.ClassNotFoundException: org.aspectj.weaver.reflect.ReflectionWorld$ReflectionWorldException at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1313) at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1164) ... 44 more五月 04, 2016 10:21:48 上午 org.apache.catalina.core.StandardContext startInternal严重: One or more listeners failed to start. Full details will be found in the appropriate container log file五月 04, 2016 10:21:48 上午 org.apache.catalina.core.StandardContext startInternal严重: Context [/scm1.2] startup failed due to previous errors五月 04, 2016 10:21:48 上午 org.apache.catalina.core.ApplicationContext log信息: Closing Spring root WebApplicationContext五月 04, 2016 10:21:48 上午 org.apache.catalina.loader.WebappClassLoaderBase clearReferencesJdbc警告: The web application [scm1.2] registered the JDBC driver [com.mysql.jdbc.Driver] but failed to unregister it when the web application was stopped. To prevent a memory leak, the JDBC Driver has been forcibly unregistered.五月 04, 2016 10:21:48 上午 org.apache.catalina.loader.WebappClassLoaderBase clearReferencesThreads警告: The web application [scm1.2] appears to have started a thread named [Timer-0] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread: java.lang.Object.wait(Native Method) java.util.TimerThread.mainLoop(Timer.java:552) java.util.TimerThread.run(Timer.java:505)五月 04, 2016 10:21:48 上午 org.apache.catalina.loader.WebappClassLoaderBase clearReferencesThreads警告: The web application [scm1.2] appears to have started a thread named [com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread-#0] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread: java.lang.Object.wait(Native Method) com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread.run(ThreadPoolAsynchronousRunner.java:534)五月 04, 2016 10:21:48 上午 org.apache.catalina.loader.WebappClassLoaderBase clearReferencesThreads警告: The web application [scm1.2] appears to have started a thread named [com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread-#1] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread: java.lang.Object.wait(Native Method) com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread.run(ThreadPoolAsynchronousRunner.java:534)五月 04, 2016 10:21:48 上午 org.apache.catalina.loader.WebappClassLoaderBase clearReferencesThreads警告: The web application [scm1.2] appears to have started a thread named [com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread-#2] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread: java.lang.Object.wait(Native Method) com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread.run(ThreadPoolAsynchronousRunner.java:534)五月 04, 2016 10:21:48 上午 org.apache.catalina.loader.WebappClassLoaderBase clearReferencesThreads警告: The web application [scm1.2] appears to have started a thread named [Abandoned connection cleanup thread] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread: java.lang.Object.wait(Native Method) java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:142) java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:158) com.mysql.jdbc.NonRegisteringDriver$1.run(NonRegisteringDriver.java:93)五月 04, 2016 10:21:48 上午 org.apache.coyote.AbstractProtocol start信息: Starting ProtocolHandler ["http-nio-8080"]五月 04, 2016 10:21:48 上午 org.apache.coyote.AbstractProtocol start信息: Starting ProtocolHandler ["ajp-nio-8009"]五月 04, 2016 10:21:48 上午 org.apache.catalina.startup.Catalina start信息: Server startup in 17888 ms 经过各种查资料： 发现是少了个jar包： com.springsource.org.aspectj.weaver-1.6.8.RELEASE有些版本也叫：aspectj.weaver.jar]]></content>
      <categories>
        <category>踩过的坑</category>
      </categories>
      <tags>
        <tag>j2ee</tag>
        <tag>异常</tag>
        <tag>spring</tag>
        <tag>aop</tag>
      </tags>
  </entry>
</search>
